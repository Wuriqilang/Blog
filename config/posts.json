{
  "posts": [
    {
      "content": "面试京东和阿里的时候，面试官都问到了虚拟Dom与页面渲染的相关问题，鄙人支支吾吾，颠三倒四的回答了一个大概，引以为耻。\n确实，对于一名前端工程师来说，想要针对性的对项目做优化就一定绕不开页面渲染机制。本文将从Vue Virtual DOM实现的角度出发，讨论前端最重要的知识点：页面渲染。\n\n<!-- more -->\n\n写在最前面：本文中提出的一些关于浏览器内核观点可以参考另外一片文章 [浏览器内核的三国风云](https://www.xr1228.com/post/liulanqisanguo/)\n值得说明的是，本文撰写过程中我愈发发现每一个涉及的知识点都可以单独写一篇文章，也愈发发现自己的无知，但作为一名以解决问题为目标的工程师，很多细碎的知识点我们的原则是尽量“不求甚解”。\n\n## 一、一个页面是如何渲染出来的？\n\n我们知道浏览器主要由七个模块组成的，七个模块相互配合，实现网络资源的请求、解析、重拍、渲染、交互。\n\n![](https://www.xr1228.com//post-images/1593653719143.png)\n\n- User Interface（用户界面）：包括地址栏、后退/前进按钮、收藏栏等，即用户看到的除了页面之外的浏览器界面。\n- Browser engine（浏览器引擎）：\n    - 在用户界面与渲染引擎之间传送指令。保证浏览器各个部分之间互相通信\n    - 访问客户端本地缓存（或长期保存）的数据，对这些数据进行读写。\n- DataPersistence（数据存储）：浏览器中保存的cookie、localStorage等数据。\n- Rendering engine（浏览器内核）：实际上这个单词的准确翻译是：**渲染引擎**。之所以翻译为浏览器内核，是因为本文的观点认为浏览器内核包含了渲染引擎与JS引擎。浏览器内核主要功能是解析DOM文档和CSS规则，并将内容排版到浏览器中。\n- Networking（网络）：用来完成网络调用或者资源下载的模块\n- JavaScript Interpreter（JS解释器）：即JS引擎，用来解释执行JS脚本，如V8（Chromium Blink），JavaScriptCore（webkit）\n- UI Backend（UI模块）：用来绘制基本浏览器控件，如输入框、按钮、选择按钮等，根据不同浏览器绘制效果也有差异，但功能相同。\n\n\n### 1.1 渲染引擎工作流程\n\n> 因为目前采用webkit内核（chrome blink与webkit的渲染过程类似）的浏览器占据了90%以上的市场份额，所以本文仅讨论该内核。（其他的知识我不要知道不要知道。。。）\n\n1.  **解析HTML生成DOM树**：渲染引擎将HTML标签解析成由多个DOM元素对象节点组成的具有父子关系的DOM树结构。\n2.  **解析CSS生成CSSOM规则树**\n3.  **生成渲染树**： 将DOM树与CSSOM规则树合并，根据DOM树结构的每一个节点顺序提前计算使用的CSS规则并重新计算DOM树结构的样式数据，生成一个带有样式描述的DOM渲染树对象。\n4.  **渲染树布局**：遍历渲染树，根据渲染树节点在页面中的大小和位置，将渲染树节点固定到页面的位置上,这个阶段只有元素的布局属性(position,float,margin)生效.\n5. **绘制渲染树**：将渲染树节点的背景、颜色、文本等样式信息应用的节点上，这个阶段主要是元素的内部显示样式（color，background等属性）生效。\n\n> 渲染引擎对与DOM渲染树的解析和输出是**逐行进行**的.这样渲染树前面的内容可以先展示，这样保证了较好的用户体验。\n\n![](https://www.xr1228.com//post-images/1593655664644.jpg)\n\n在这里我们需要注意的是在渲染树**布局**和**绘制**阶段：\n\n- 页面重排（reflow）：页面在生成后如果页面元素位置或尺寸发生改变，**一旦页面reflow则必定会repaint**\n- 页面重绘（repaint）：屏幕的一部分重画，不影响整体布局，比如css的背景色变化，但是元素的尺寸和位置不变。显示样式发生改变但是布局即元素位置不发生改变\n\nreflow产生的代价要远大于repaint，所以我们要尽量避免reflow，减少repaint\n\n\n### 1.2 渲染阻塞\n- **JS执行阻塞**：当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：\n    - CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。\n    - JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。\n\n- **CSS解析阻塞**：当解析html的时候，会把新来的元素插入dom树里面，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。例如： div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。\n\n## 二、一切都很美好，为什么要用Virtual-DOM ？\n\n### 2.1 操作DOM元素的代价\n\n首先我们应该有一个概念，在前端项目中，一个DOM是很“昂贵”的。你可以在浏览器命令行中执行以下代码，打印一个最简单div元素中所有属性\n\n```js\nvar div = document.createElement('div');\nvar str = '';\nfor(var key in div){\n    str += key + '  '\n}\n```\n![](https://www.xr1228.com//post-images/1593659368665.PNG)\n\n这仅仅是一个最简单的dom元素. 当我们通过JavaScript操作页面中dom节点时,浏览器会从构建DOM树开**始从头到尾执行一遍**渲染流程. (有些情况下也会集中处理,这里不做讨论).\n假如我们要更新10个DOM节点, 浏览器接收到第一个更新请求时会马上执行, 连续执行10次,而事实上最后一次执行的结果才是我们需要的. 前九次运算都是在浪费性能. 最终导致页面卡顿,内存占用过高,用户体验差.\n\n![](https://www.xr1228.com//post-images/1593659945748.jpg)\n\n### 2.2 虚拟DOM的好处\n\n虚拟DOM就是为了解决浏览器性能问题而被设计出来的. \n\n假如一次操作中有10个更新DOM的动作,虚拟DOM不会立即执行,而是将这10次更新的diff内容保存到本地的JS对象中,最终将这个JS对象一次性 attch到DOM树上,再进行后续操作,避免大量无效计算. 这样页面的更新可以全部反应在JS对象(虚拟DOM上),操作内存中的JS对象速度当然要更快,等更新完后再将JS对象映射成真实的DOM,交给浏览器去绘制.\n\n> 除了性能优化外,虚拟DOM实现让服务端渲染,跨端渲染成为了可能.\n\n\n## 三、Virtual DM的实现\n\n###  3.1 Vue 的 Virtual DOM\n\nVirtual DOM就是用一个原生的JS对象去描述DOM节点,所以它比创建一个DOM的代价要小很多. 在Vue中,Virtual DOM是用 VNode(一个Class)去描述的,它定义在 src/core/vdom/vnod.js 中.\n\n```js\nexport default class VNode {\n  tag: string | void;\n  data: VNodeData | void;\n  children: ?Array<VNode>;\n  text: string | void;\n  elm: Node | void;\n  ns: string | void;\n  context: Component | void; // rendered in this component's scope\n  key: string | number | void;\n  componentOptions: VNodeComponentOptions | void;\n  componentInstance: Component | void; // component instance\n  parent: VNode | void; // component placeholder node\n\n  // strictly internal\n  raw: boolean; // contains raw HTML? (server only)\n  isStatic: boolean; // hoisted static node\n  isRootInsert: boolean; // necessary for enter transition check\n  isComment: boolean; // empty comment placeholder?\n  isCloned: boolean; // is a cloned node?\n  isOnce: boolean; // is a v-once node?\n  asyncFactory: Function | void; // async component factory function\n  asyncMeta: Object | void;\n  isAsyncPlaceholder: boolean;\n  ssrContext: Object | void;\n  fnContext: Component | void; // real context vm for functional nodes\n  fnOptions: ?ComponentOptions; // for SSR caching\n  fnScopeId: ?string; // functional scope id support\n\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array<VNode>,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions,\n    asyncFactory?: Function\n  ) {\n    this.tag = tag\n    this.data = data\n    this.children = children\n    this.text = text\n    this.elm = elm\n    this.ns = undefined\n    this.context = context\n    this.fnContext = undefined\n    this.fnOptions = undefined\n    this.fnScopeId = undefined\n    this.key = data && data.key\n    this.componentOptions = componentOptions\n    this.componentInstance = undefined\n    this.parent = undefined\n    this.raw = false\n    this.isStatic = false\n    this.isRootInsert = true\n    this.isComment = false\n    this.isCloned = false\n    this.isOnce = false\n    this.asyncFactory = asyncFactory\n    this.asyncMeta = undefined\n    this.isAsyncPlaceholder = false\n  }\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n```\n\n当然了,即使我在努力的告诉你它开销很小,但实际VNode还是有些复杂的,这是因为Vue在借鉴一个开源库[snabbdom](https://github.com/snabbdom/snabbdom) 的基础上针对Vue的特性做了一些实现.\n\n其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。\nVirtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。\n\n接下来,我们会用一个相对比较长的篇幅来描述Virtual DOM的算法实现,话不多说,开车!\n\n![](https://www.xr1228.com//post-images/1593668470261.jpeg)\n\n\n\n### 3.2  Virtual DOM的实现\n\n![](https://www.xr1228.com//post-images/1593668619504.png)\n\n通过上图我们可以直观的看到从Vue初始化到最终渲染的过程，本节的思路主要来源于 [深入剖析：Vue核心之虚拟DOM 掘金-你是我的超级英雄](https://juejin.im/post/5d36cc575188257aea108a74)  这篇文章从Virtual DOM的实现到Vue VNode源码都做了详细的分析。\n\n#### 3.2.1 用JS对象模拟DOM树\n\n假设我们需要表示这样一个真实的DOM节点：\n\n```html\n<div id=\"virtual-dom\">\n<p>Virtual DOM</p>\n<ul id=\"list\">\n  <li class=\"item\">Item 1</li>\n  <li class=\"item\">Item 2</li>\n  <li class=\"item\">Item 3</li>\n</ul>\n<div>Hello World</div>\n</div> \n```\n\n我们希望通过JavaScript中的对象来表示这样的DOM节点,并使用对象的属性来记录节点的类型,属性,子节点等信息.   首先我们编写一个 element 模块\n\n> 本文为了方便你直接在浏览器中操作而无需开启一个nodejs环境,本例使用了浏览器原生支持的 ES-Module 引入方式(我相信这也是未来前端构建项目的最佳方式), 当然你也可以通过webpack,browserify等方法来编译js文件,使浏览器可以通过require或import调用模块.\n\n```js\n/**\n * Element Virtual-dom 对象定义\n * @param {String} tagName - dom元素名称\n * @param {Object} props - dom属性\n * @param {Array<ELEMENT|String>} -子节点\n */\nfunction Element(tagName,props,children){\n    this.tagName = tagName;\n    this.props = props;\n    this.children = children;\n    //dom元素的key值,用作唯一标识符\n    if(props.key){\n        this.key = props.key\n    }\n    var count = 0 ;\n    children.forEach((child,i) => {\n        if(child instanceof Element){\n            count += child.count;\n        }else{\n            children[i] = '' + child;\n        }\n        count ++;\n    });\n    //子元素的个数\n    this.count = count;\n}\nfunction createElement(tagName,props,children){\n    return new Element(tagName,props,children);\n}\nexport default createElement;\n```\n接下来,根据element对象的设定,我们可以将上述的DOM结构表示出来,并打印在控制台中.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Virtual DOM实现</title>\n</head>\n<body>\n    <div id=\"virtual-dom\">\n        <p>Practical DOM</p>\n        <ul id=\"list\">\n            <li class=\"item\">Item 1</li>\n            <li class=\"item\">Item 2</li>\n            <li class=\"item\">Item 3</li>\n        </ul>\n        <div>Hello World</div>\n    </div>\n    <script type=\"module\">\n        import el from './Element.js'\n        var virtualDom = el('div', { id: 'virtual-dom' }, [\n            el('p', {}, ['Virtual DOM']),\n            el('ul', { id: 'list' }, [\n                el('li', { class: 'item' }, ['Item 1']),\n                el('li', { class: 'item' }, ['Item 2']),\n                el('li', { class: 'item' }, ['Item 3'])\n            ]),\n            el('div', {}, ['Hello World'])\n        ])\n        console.log(\"Virtual Dom:\");\n        console.log(virtualDom);\n        console.log(\"Practical Dom:\");\n        console.log(document.getElementById(\"virtual-dom\"));\n    </script>\n</body>\n</html>\n```\n\n在本例中我还写了一个 真实DOM,你可以从控制台中直观的比较两者的差异\n\n![](https://www.xr1228.com//post-images/1593680905126.PNG)\n\n#### 3.2.2 将模拟DOM树渲染到页面中\n\n上面的例子我们将DOM改造为一个 自定义的element对象,那么如何将这个对象渲染成真实的DOM结构呢?\n让我们对 element对象进行改造.  其实就是对Element对象的原型增加一个render函数. 改造后的Element.js 如下\n\n```js\n/**\n * Element Virtual-dom 对象定义\n * @param {String} tagName - dom元素名称\n * @param {Object} props - dom属性\n * @param {Array<ELEMENT|String>} -子节点\n */\nfunction Element(tagName,props,children){\n    this.tagName = tagName;\n    this.props = props;\n    this.children = children;\n    //dom元素的key值,用作唯一标识符\n    if(props.key){\n        this.key = props.key\n    }\n    var count = 0 ;\n    children.forEach((child,i) => {\n        if(child instanceof Element){\n            count += child.count;\n        }else{\n            children[i] = '' + child;\n        }\n        count ++;\n    });\n    //子元素的个数\n    this.count = count;\n}\n/**\n * render 将virdual-dom对象渲染为真实DOM元素\n */\n Element.prototype.render = function(){\n     var el = document.createElement(this.tagName);\n     var props = this.props;\n     //设置节点DOM属性\n     for(var propName in props){\n         var propValue = props[propName];\n         el.setAttribute(propName,propValue);\n     }\n\n     var children = this.children||[];\n     children.forEach(child=>{\n         var childEl = (child instanceof Element)\n         ?child.render() //如果子节点也是虚拟DOM,递归构建DOM节点\n         :document.createTextNode(child);  //如果是字符串,只构建文本节点\n         el.appendChild(childEl);\n     })\n     return el;\n }\nfunction createElement(tagName,props,children){\n    return new Element(tagName,props,children);\n}\nexport default createElement;\n```\n\n接下来,我们只需在 html中调用一下这个函数生成一个真实DOM树,添加到页面中即可\n在html中加入下面两行代码\n```js\n        //渲染虚拟DOM\n        var ulRoot = virtualDom.render();\n        document.body.appendChild(ulRoot);\n```\n\nbingo! 页面body中加入了一个DOM结构,效果如图所示:\n\n![](https://www.xr1228.com//post-images/1593765774653.png)\n\n#### 3.2.3 计算两棵Virtual DOM树的算法实现 diff\n\n接下来,当我们修改Virtual DOM之后,需要比较修改前后的DOM树的差异,然后返回一个patch对象,即补丁对象,再通过特定的解析patch对象,完成页面的渲染.  \n\n大概流程是这样的: \n\n![](https://www.xr1228.com//post-images/1593768412866.PNG)\n\n到这里,聪明的你一定会问 : 为啥要对比呢? 我把新的Virtual Dom渲染出来不就行了吗? 向上一节一样 调用document.CreateElement不就OK了吗? 何必多次一举?\n\n这是因为document.CreateElement这个操作开销也很大,它本质就是新建一个DOM结构,对于性能是一个巨大的浪费. 为了减少性能损耗, 我们需要通过 diff + patch 的方式实现DOM结构的更新.\n\n接下来我们实现一个 diff算法.\n\n- **diff算法**：diff就是用来比较两颗Virtual Dom差异的算法。如果是由你来实现这段功能，我们可能会遍历两棵DOM树中的每一个节点，将其进行对比，这样的化时间复杂度将会是$O(n^3)$ → (两颗树遍历是$O(n^2)$,再做一次更新操作,时间复杂度就是$O(n^3)$)\n但是在我们前端实际操作DOM元素过程中,极少会遇到跨越层级调动DOM元素的情况,所以Virtual DOM只会对同一层级的与阿奴进行对比.这样时间复杂度就可以达到 O(n).\n\n![](https://www.xr1228.com//post-images/1593996871511.PNG)\n\n**(1) 深度优先遍历,记录差异**\n首先我们可以对新旧两颗树进行一个**深度优先遍历**,这样每个节点都会有一个唯一标记.\n\n![](https://www.xr1228.com//post-images/1593997028669.PNG)\n\n在深度优先遍历的同时,每遍历到一个节点就把这个节点和新的树进行对比,如果有差异的话就记录到一个对象中.\n我们新建一个diff.js文件来存放diff方法的代码:\n```js\n/**\n * diff函数,对比两颗树\n * @param {Element} oldTree - 之前的树\n * @param {Element} newTree - 新的Virtual DOM树\n */\nfunction diff(oldTree, newTree) {\n    var index = 0; //当前节点的标志\n    var patches = {}; // 用来记录每个节点差异的对象\n    dfsWalk(oldTree, newTree, index, patches);\n    return patches;\n}\n\n//对两棵树进行深度优先遍历\nfunction dfsWalk(oldNode, newNode, index, patches) {\n    var currentPatch = [];\n    if (typeof (oldNode) === \"string\" && typeof (newNode) === \"string\") {\n        //文本内容改变\n        if (newNode !== oldNode) {\n            currentPatch.push({ type: patch.TEXT, context: newNode })\n        }\n    } else if (newNode != null && oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) {\n        //节点相同,比较属性\n        var propsPathes = diffProps(oldNode, newNode);\n        if (propsPathes) {\n            currentPatch.push({ type: patch.PROPS, props: propsPathes });\n        }\n        //比较子节点,如果子节点有'ignore'属性,则不需要比较\n        if (!isIgnoreChildren(newNode)) {\n            diffChildren(oldNode.children, newNode.children, index, patches, currentPatch);\n        }\n    } else if (newNode !== null) {\n        //新旧节点不相同,用replace替换\n        currentPatch.push({ type: patch.REPLACE, node: newNode });\n    }\n\n    if (currentPatch.length) {\n        patches[index] = currentPatch;\n    }\n}\n\n// 遍历子节点\nfunction diffChildren(oldChildren, newChildren, index, patches, currentPatch) {\n    var diffs = listDiff(oldChildren, newChildren, 'key')\n    newChildren = diffs.children\n\n    if (diffs.moves.length) {\n        var reorderPatch = { type: patch.REORDER, moves: diffs.moves }\n        currentPatch.push(reorderPatch)\n    }\n\n    var leftNode = null\n    var currentNodeIndex = index\n    oldChildren.forEach((child, i) => {\n        var newChild = newChildren[i]\n        currentNodeIndex = (leftNode && leftNode.count)\n            ? currentNodeIndex + leftNode.count + 1\n            : currentNodeIndex + 1\n        dfsWalk(child, newChild, currentNodeIndex, patches)\n        leftNode = child\n    })\n}\n\n// 比较节点属性\nfunction diffProps(oldNode, newNode) {\n    var count = 0\n    var oldProps = oldNode.props\n    var newProps = newNode.props\n    var propsPatches = {}\n    // 查找属性值不同的属性\n    for (var key in oldProps) {\n        if (newProps[key] !== oldProps[key]) {\n            count++\n            propsPatches[key] = newProps[key]\n        }\n    }\n    // 查找新属性\n    for (var key in newProps) {\n        if (!oldProps.hasOwnProperty(key)) {\n            count++\n            propsPatches[key] = newProps[key]\n        }\n    }\n    // 没有属性改变\n    if (count === 0) {\n        return null\n    }\n    return propsPatches\n}\n\nfunction isIgnoreChildren(node) {\n    return (node.props && node.props.hasOwnProperty('ignore'))\n}\n```\n这样我们就实现了对两个Virtual DOM树的比较，并且返回一个patches对象，记录了节点之间的差异。当然，你马上会发现这段代码还无法使用，因为其中有一个对象patch和一个方法listDiff没有实现。接下来对其进行详细说明。\n\n\n**(2) 标记节点之间的差异类型**\n当我们对DOM节点进行对比的时候，需要对差异进行标记，这样就能告诉程序两个节点之间的差异类型，以便程序根据不同类型执行不同的操作。\n\nDOM操作导致的差异类型主要包括以下几点：\n- 节点替换：节点改变了，例如将上面的 div 换成 h1;\n- 顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换；\n- 属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除；\n- 文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Virtual DOM2”；\n\n为了描述上述的差异，我们新建一个 patch.js(之所以要新建一个文件是因为在patch.js中我们还要实现操作真是DOM的操作)\n```js\nvar REPLACE = 0 // 替换原先的节点\nvar REORDER = 1 // 重新排序\nvar PROPS = 2 // 修改了节点的属性\nvar TEXT = 3 // 文本内容改变 \n\nfunction patch(node, patches) {\n    //实现操作真实DOM的代码,暂时不写\n}\npatch.REPLACE = REPLACE\npatch.REORDER = REORDER\npatch.PROPS = PROPS\npatch.TEXT = TEXT\n\nexport default patch;\n```\n\n**（3）列表对比算法(性能优化)**\n到此为止,一切都显得自然而简单,我们对比两颗Virtual DOM树,生成差异对象,再通过差异对象来操作真实DOM.  但是其有很大的性能优化空间:\n**列表对比**: \n我们先看一下这两棵Virtual DOM:\n```js\n        var virtualDom = el('div', { id: 'virtual-dom' }, [\n            el('p', {}, ['Virtual DOM']),\n            el('ul', { id: 'list' }, [\n                el('li', { class: 'item' }, ['Item 1']),\n                el('li', { class: 'item' }, ['Item 2']),\n                el('li', { class: 'item' }, ['Item 3'])\n            ]),\n            el('div', {}, ['Hello World'])\n        ])\n\n        //再新建一颗Virtual-Dom\n        var virtualDom2 = el('div', { id: 'virtual-dom' }, [\n            el('ul', { id: 'list' }, [\n                el('li', { class: 'item' }, ['Item 1']),\n                el('li', { class: 'item' }, ['Item 2']),\n                el('li', { class: 'item' }, ['Item 3'])\n            ]),\n            el('div', {}, ['Hello World']),\n            el('p', {}, ['Virtual DOM'])\n        ])\n```\n在这两棵树中,子节点的顺序从 p,ul,div 变成了 ul,div,p .如果我们按照同层级进行顺序对比的话,他们都会标记为 replace.进而都被替换掉.这样一来DOM操作的开销就会很大 . 实际上我们无需进行替换节点,只要通过移动节点就可以了.\n\n上面这个问题抽象出来其实就是 字符串的最小编辑问题([EditionDistance](https://blog.csdn.net/zp1996323/article/details/51702991))   \n\n对于一个解决问题为主的工程师来说没,了解Edition Distance其实没什么用,而且你也很快会忘掉.所以这里先放结论 :  为了解决列表对比的问题, 我们采用了插件 [list-diff2](https://github.com/livoras/list-diff) 算法.   我这个算法的核心文件引用到了项目的 list-diff.js 中, EditionDistance的算法原理在本文最后,时间多的用不完的你可以看一看.\n\nlist-diff2 的代码如下, 你可以新建一个 list-diff.js    篇幅所限, 本文代码在 [virtual-DOM中](https://github.com/Wuriqilang/PlayGround/tree/master/Virtual%20Dom)\n\n接下来只需要将写好的 patch.js和list-diff.js 引入到  diff.js中即可. 再次郑重说明,本文项目采用了ES Module引用方式,无需nodejs环境,引用时注意import语法\n\n```js\nimport patch from './patch.js';  //存放差异类型\nimport listDiff from './uilts/list-diff.js'; //实现列表对比算法\n```\n\n现在我们测试一下效果吧. 改写 html页面如下:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Virtual DOM实现</title>\n</head>\n\n<body>\n    <div id=\"virtual-dom\">\n        <p>Practical DOM</p>\n        <ul id=\"list\">\n            <li class=\"item\">Item 1</li>\n            <li class=\"item\">Item 2</li>\n            <li class=\"item\">Item 3</li>\n        </ul>\n        <div>Hello World</div>\n    </div>\n    <script type=\"module\">\n        import el from './Element.js';\n        import diff from './diff.js';\n\n        var virtualDom = el('div', { id: 'virtual-dom' }, [\n            el('p', {}, ['Virtual DOM']),\n            el('ul', { id: 'list' }, [\n                el('li', { class: 'item' }, ['Item 1']),\n                el('li', { class: 'item' }, ['Item 2']),\n                el('li', { class: 'item' }, ['Item 3'])\n            ]),\n            el('div', {}, ['Hello World'])\n        ])\n        console.log(\"Virtual Dom:\");\n        console.log(virtualDom);\n        console.log(\"Practical Dom:\");\n        console.log(document.getElementById(\"virtual-dom\"));\n        //渲染虚拟DOM\n        var ulRoot = virtualDom.render();\n        document.body.appendChild(ulRoot);\n\n        //再新建一颗Virtual-Dom\n        var virtualDom2 = el('div', { id: 'virtual-dom2' }, [\n            el('p', {}, ['Virtual DOM2']),\n            el('ul', { id: 'list' }, [\n                el('li', { class: 'item' }, ['Item 21']),\n                el('li', { class: 'item' }, ['Item 23'])\n            ]),\n            el('p', {}, ['Hello World'])\n        ])\n\n        //对比两棵树差异\n        var patches = diff(virtualDom, virtualDom2);\n        console.log('patches:', patches);\n    </script>\n</body>\n\n</html>\n```\n在这个例子中,我们写了两个 Virtual DOM, 调用 diff.js 来比较两棵树的差异,生成 patches.这样我们就可以通过这个差异对象来更改真实DOM结构. 从而在尽量少的DOM操作前提下,完成DOM树的更新.\n\n![](https://www.xr1228.com//post-images/1594286825417.PNG)\n\n#### 3.2.3 将差异对象(patches) 应用到真实DOM树\n\n因为3.2.1中我们通过Virtual DOM构建出的真实DOM树与Virtual DOM信息、结构是完全相同的.所以我们对真实DOM也进行深度优先遍历,遍历的过程中与patches相互对比: \n\n我们在 path.js中写出相关代码:\n\n```js\nfunction patch(node, patches) {\n    var walker = { index: 0 };  //记录节点位置\n    dfsWalk(node, walker, patches); //深度优先遍历真实DOM\n}\n\nfunction dfsWalk(node,walker,patches){\n    //从patches中拿出差异\n    var currentPatches = patches[walker.index];\n\n    var len = node.childNodes?node.childNodes.length:0;\n    //深度遍历子节点\n    for(var i=0;i<len;i++){\n        var child = node.childNodes[i];\n        walker.index ++;\n        dfsWalk(child,walker,patches);\n    }\n    //对当前节点进行DOM操作\n    if(currentPatches){\n        applyPatches(node,currentPatches);\n    }\n}\n```\n在这个递归函数中,我们每一次递归都会调用applyPatches函数,这个函数就是用操作真实DOM的函数.其核心代码如下，详细代码请参照: [virtual-DOM中](https://github.com/Wuriqilang/PlayGround/tree/master/Virtual%20Dom)\n\n```js\nfunction applyPatches(node, currentPatches) {\n    currentPatches.forEach(currentPatch => {\n        switch (currentPatch.type) {\n            case REPLACE:\n                var newNode = (typeof currentPatch.node === \"string\")\n                    ? document.createTextNode(currentPatch.node) : currentPatch.node.render();\n                node.parentNode.replaceChild(newNode, node);\n                break;\n            case REORDER:\n                reorderChildren(node, currentPatch.moves);\n                break;\n            case PROPS:\n                setProps(node, currentPatch.props);\n                break;\n            case TEXT:\n                node.textContent = currentPatch.content;\n                break;\n            default:\n                throw new Error(\"Unknown patch type\" + currentPatch.type);\n        }\n    })\n}\n```\n这样，Vitural DOM核心功能就完成了啦。 接下来我们对html做一些修改，让我们的Virtual DOM系统更加直观,并且能够反应Vitural Dom系统的性能.\n这段为了实现浏览器原生ES Module(脱离nodejs webpack) 加载模块的方式,对于代码进了一些设计,你可以结合ES Module相关知识理解一下.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Virtual DOM实现</title>\n    <style>\n        body {\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n        }\n\n        #Practical-dom,#virtual-dom,#virtual-dom2 {\n            width: 300px;\n            border: 1px solid red;\n            border-radius: 10px;\n            padding: 10px;\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n        }\n        .button{\n            width:300px;\n            padding:10px;\n        }\n    </style>\n</head>\n\n<body>\n    <h1>virtual-dom系统</h1>\n    <div id=\"Practical-dom\">\n        <p>Practical DOM（一个真实DOM）</p>\n        <ul id=\"list\">\n            <li class=\"item\">Item 1</li>\n            <li class=\"item\">Item 2</li>\n            <li class=\"item\">Item 3</li>\n        </ul>\n        <div>Hello World</div>\n    </div>\n    <br>\n    <br>\n\n    <button class=\"button\" onclick=\"renderDom1()\">渲染virtualDOM1</button>\n    <button class=\"button\" onclick=\"renderDom2()\">直接渲染virtualDOM2</button>\n    <button class=\"button\" onclick=\"diff()\">通过diff算法对比后更新真实DOM1</button>\n\n    <script type=\"module\">\n        import el from './Element.js';\n        import diff from './diff.js';\n        import patch from \"./patch.js\";\n\n        console.log(\"Practical Dom:\");\n        console.log(document.getElementById(\"Practical-dom\"));\n        window.vd = { el, diff, patch };  //将el diff patch放入全局作用域中\n    </script>\n\n    <script>\n        var ulRoot;//定义一个对象存放生成的真实DOM对象\n        var ulRoot2;///定义一个对象存放生成的真实DOM对象\n        var virtualDom;\n        var virtualDom2;\n        var patches;\n        window.onload = function () {  //这里需要使用onload包裹起来,否则无法等待异步es module执行完毕\n            var el = window.vd.el;\n            //定义一颗Virtual Dom\n            virtualDom = el('div', { id: 'virtual-dom' }, [\n                el('p', {}, ['Virtual DOM']),\n                el('ul', { id: 'list' }, [\n                    el('li', { class: 'item' }, ['Item 1']),\n                    el('li', { class: 'item' }, ['Item 2']),\n                    el('li', { class: 'item' }, ['Item 3'])\n                ]),\n                el('div', {}, ['Hello World'])\n            ])\n            //再新建一颗Virtual-Dom\n            virtualDom2 = el('div', { id: 'virtual-dom2' }, [\n                el('p', {}, ['Virtual DOM2']),\n                el('ul', { id: 'list' }, [\n                    el('li', { class: 'item' }, ['Item 21']),\n                    el('li', { class: 'item' }, ['Item 23'])\n                ]),\n                el('p', {}, ['Hello World'])\n            ])\n        }\n        //渲染虚拟DOM\n        function renderDom1() {\n            console.log(\"Virtual Dom:\");\n            console.log(virtualDom);\n            console.time(\"直接渲染耗时\");\n            ulRoot = virtualDom.render();\n            document.body.appendChild(ulRoot);\n            console.timeEnd(\"直接渲染耗时\");\n        }\n        //渲染虚拟DOM2\n        function renderDom2() {\n            console.log(\"Virtual Dom2:\");\n            console.log(virtualDom2);\n            console.time(\"直接渲染耗时\");\n            ulRoot2 = virtualDom2.render();\n            document.body.appendChild(ulRoot2);\n            console.timeEnd(\"直接渲染耗时\");\n        }\n        function diff(){\n            console.time(\"diff算法后渲染耗时\");\n            //对比两棵树差异\n            patches = window.vd.diff(virtualDom, virtualDom2);\n            // console.log('差异对象patches:', patches);\n            window.vd.patch(ulRoot, patches);\n            console.timeEnd(\"diff算法后渲染耗时\");\n        }\n    </script>\n\n</body>\n\n</html>\n```\n\nVirtual Dom 效果如下:\n\n![](https://www.xr1228.com//post-images/1594607533007.gif)\n\n你会发现使用diff再进行渲染的方法似乎比直接渲染真实Dom更加耗时,这是因为我们例子中的Virtual-Dom简单十分简单导致的, 随着页面DOM结构复杂程度的增加,diff算法的优势也会越明显.\n\n**本文源代码** [virtual-DOM中](https://github.com/Wuriqilang/PlayGround/tree/master/Virtual%20Dom)  请参考\n\n- 参考文献：\n[chrome浏览器页面渲染工作原理浅析-知乎大金](chrome浏览器页面渲染工作原理浅析)\n[浏览器内核-渲染引擎、js引擎](https://blog.csdn.net/BonJean/article/details/78453547)\n[浏览器之渲染引擎-掘金26000步](https://juejin.im/post/5c903e23e51d45656442c5e2)\n[EditionDistance](https://blog.csdn.net/zp1996323/article/details/51702991)\n[字符串相似度算法——Levenshtein Distance算法](https://www.cnblogs.com/xiaoyulong/p/8846745.html)\n\n\n- 附:diff算法原理\n\n列表对比问题抽象出来其实就是字符串的最小编辑距离问题（Edition Distance），所谓最小编辑距离问题, 就是假设有两个字符串A与B, 怎样通过字符的插入、删除或者替换手段，用最少的步骤让B改变为A的问题.\n\n这个问题最常见的解决方法是 Levenshtein Distance ,Levenshtein Distance 是1965年由苏联数学家 Vladimir Levenshtein 发明的。Levenshtein Distance 也被称为编辑距离（Edit Distance），其原理是通过动态规划求解，时间复杂度为 O(M*N)。\n\n定义：对于两个字符串 a、b，则他们的 Levenshtein Distance 为：\n\n![](https://www.xr1228.com//post-images/1594608157829.PNG)\n\n示例：字符串 a 和 b，a=“abcde” ，b=“cabef”，根据上面给出的计算公式，则他们的 Levenshtein Distance 的计算过程如下：\n\n![](https://www.xr1228.com//post-images/1594608194253.PNG)\n\n因为篇幅所限，对于该算法你可以看一下这篇文章，写的非常详细 \n[字符串相似度算法——Levenshtein Distance算法](https://www.cnblogs.com/xiaoyulong/p/8846745.html)\n\n",
      "data": {
        "title": "【前端拾遗】它为什么这么快？—— Vue Virtual DOM详解",
        "date": "2020-07-01 15:15:18",
        "tags": [
          "vue",
          "前端拾遗",
          "值得一读"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/virtualDom.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "面试京东和阿里的时候，面试官都问到了虚拟Dom与页面渲染的相关问题，鄙人支支吾吾，颠三倒四的回答了一个大概，引以为耻。\n确实，对于一名前端工程师来说，想要针对性的对项目做优化就一定绕不开页面渲染机制。本文将从Vue Virtual DOM实现的角度出发，讨论前端最重要的知识点：页面渲染。",
      "fileName": "virtualDom"
    },
    {
      "content": "> 天下大势,分久必合,合久必分   ——  《三国演义》\r\n\r\n<!-- more -->\r\n\r\n作为一名前端开发工程师，总会在各种文档的字里行间中看“内核”，“引擎”等名词，看了许多文章，仍然是对其中一些概念懵懵懂懂，譬如“Chromium和Blink是什么关系？Chromium和Chrome是什么关系？”这直接导致我给同事吹牛时底气不足。\r\n\r\n> 犹豫，就会败北。尤其是在吹牛的时候 ——  《只狼：影逝二度》\r\n\r\n![](https://www.xr1228.com//post-images/1593566832242.jpg)\r\n\r\n## 一、最基本的概念：浏览器，内核，引擎\r\n\r\n- 浏览器：用来检索、展示以及传递Web信息资源的应用程序。记住：**浏览器是一种产品**。譬如Chrome，Chromium，FirFox，Safiar，IE，360，QQ 。。。\r\n- 内核：驱动浏览器运行的核心部分。他包括**JS引擎与渲染引擎**。但是随着JS的发展，JS引擎也愈发显得独立于复杂，浏览器内核就倾向于单指渲染引擎。但就目前而言，多数浏览器内核仍然包括了JS引擎与渲染引擎（譬如Blink内核），为了便于理解，本文的观点是：**内核包括JS引擎与渲染引擎**。譬如Blink，Webkit，Gecko\r\n- 引擎：\r\n    - JS引擎：专门处理JavaScript脚本的虚拟机（简单来说就是能够运行JS的环境）。\r\n    - 渲染引擎（也可以叫排版引擎或图像引擎）：对HTML文档进行解析并将其显示在页面上的工具。\r\n\r\n浏览器、内核、引擎的关系可以用下图所示：\r\n\r\n![](https://www.xr1228.com//post-images/1593573021116.png)\r\n\r\n还有一些遗失在前端发展历史进程中或者市场使用率很低的浏览器与内核（IE，EdgeHtml，Netscape ...) 为了文章简洁且具有现实意义，本文就不做讨论了，让我们向参与这些项目的程序员致敬。\r\n\r\n![](https://www.xr1228.com//post-images/1593573273158.jpg)\r\n\r\n## 二、浏览器的三国大势\r\n\r\n视频展示了 2009年到2020年各浏览器的市场占用情况，风云变幻，百家争鸣。[视频来源-bilibli Data_Fun](https://www.bilibili.com/video/BV1iK41157eK?from=search&seid=8186579024934449220)\r\n\r\n<div class=\"aspect-ratio\">\r\n<iframe src=\"https://player.bilibili.com/player.html?aid=498000935&bvid=BV1iK41157eK&cid=187449223&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" sandbox=\"allow-top-navigation allow-same-origin allow-forms allow-scripts\"> </iframe></div>\r\n\r\n作为一名以解决问题为核心的工程师，我们不必关心浏览器战争背后的故事，我们知道就目前而言，对于前端开发者来说我们主要需要对Blink与Webkit内核的浏览器做适配就足够了（该结论写于2020.7.1）\r\n\r\n**未来？**随着Edge开始基于Chromium开发，浏览器内核的发展呈现逐渐一家独大的趋势。但是我们也应该看到为了应对移动端的发展，各家大厂也在研发新的浏览器，或是更加关注隐私（FireFox Focus），或是针对安卓进行了底层优化，亦或是针对自家生态的定制（微信x5）。\r\n同时，随着Http3，WebAssembly，更快的网速，更复杂的WebApp交互需求，浏览器的变化仍未定型。身为一名开发工程师，我庆幸自己生活在这样一个时代。\r\n\r\n> 有时候，不确定就代表潜力。\r\n\r\n\r\n## 三、为什么要写这篇文章？\r\n\r\n这篇文章似乎有一些标题党，其实我本身并不想讨论关于浏览器大战的细节与历史，这些历史也无法对实际工作产生比较大的作用，我仅仅是通过这篇文章来厘清浏览器、内核、引擎之间的关系。为后续研究浏览器内核渲染机制，乃至Vue Virtual Dom，nextTick的作用原理做铺垫。\r\n\r\n```js\r\n//TODO：完成浏览器渲染机制，Vue Virtual Dom，nextTick相关学习\r\n```",
      "data": {
        "title": "【前端拾遗】浏览器内核的三国风云",
        "date": "2020-07-01 09:02:04",
        "tags": [
          "值得一读",
          "前端拾遗"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/liulanqisanguo.PNG",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "> 天下大势,分久必合,合久必分   ——  《三国演义》\r",
      "fileName": "liulanqisanguo"
    },
    {
      "content": "数据双向绑定，作为三大前端框架的重要特性，总是被人们津津乐道（尤其是面试官），defineProperty啦，proxy啦，digest循环检查啦（AngularJS）……数据绑定的相关文章看了很多，但总是感觉差点意思,还是自己亲自实现一个数据绑定吧\r\n\r\n\r\n<!-- more -->\r\n\r\n\r\n注:本文主要观点与思路学习了 [前端攻城狮-vue的双向绑定原理及实现](https://www.cnblogs.com/canfoo/p/6891868.html)\r\n\r\n\r\n## Object.defineProperty  方式\r\n\r\nObject.defineProperty 是Vue 2.X的实现方式，其原理就是在Vue实例中定义data时：\r\n①Vue遍历data中所有数据，\r\n②通过ES5的Object.defineProperty 重写data中的每一项数据的set属性\r\n③一旦监听器发现数据发生改变，（如果是view层的数据改变时通过事件监听的，vm层是数据赋值的方法）就会触发set函数\r\n④set函数中包含了重新渲染view页面的方法，一旦触发set就可以重新渲染页面。\r\n\r\n流程就是这样一个流程，但是在代码层面需要为此实现一些必要的功能：\r\n\r\n- 实现一个监听器Observer，用来劫持并且监听所有属性。\r\n- 实现一个订阅者Wathcer，收到Observer传来的变化通知，执行相应函数来更新View页面.(为了统一管理Watcher,我们还会实现一个Dep——订阅器)\r\n- 实现一个解析器Compile，可以扫描View中每个节点上的相关指令（如v-model）从而初始化watcher和模板数据。\r\n\r\n![](https://www.xr1228.com//post-images/1591348688902.PNG)\r\n\r\n\r\n### 0.最终效果演示\r\n\r\n![](https://www.xr1228.com//post-images/1591757508655.gif)\r\n### 1.实现一个Observer\r\n\r\nObserver是一个数据监听器，其实现的核心方法就是Object.defineProperty() 如果要对所有属性都进行监听的话，可以通过递归来遍历所有属性。\r\n\r\n```js\r\nfunction obverve(data){\r\n    if(!data || typeof data !== 'object'){\r\n        return;\r\n    }\r\n    Object.keys(data).forEach(key=>{\r\n        difineReactive(data,key,data[key]);\r\n    })\r\n}\r\n\r\nfunction difineReactive(data,key,val){\r\n    obverve(val); //通过递归遍历所有子属性\r\n    Object.defineProperty(data,key,{\r\n        enumerable:true,\r\n        configurable:true,\r\n        get:function(){\r\n            return val;\r\n        },\r\n        set:function(newVal){\r\n            val = newVal;\r\n            console.log('属性'+key+'已加入监听器,现在值为:\"'+newVal.toString()+'\"');\r\n        }\r\n    })\r\n}\r\n```\r\n上述代码定义了一个监听器,这个监听器遍历传入的对象的每一项属性,为其执行一个defineReactive方法,defineReactive方法调用es5自带的Object.defineProperty(),为其添加get和set属性. 让我们来测试一下:\r\n```js\r\nconsole.log(demo);\r\n// { data1: [Getter/Setter], data2: [Getter/Setter] }     已经为属性增加了getter与setter\r\ndemo.data1.name=\"haha\"\r\n//属性name已加入监听器,现在值为:\"haha\"\r\n//'haha'\r\ndemo.data2 = 'test'\r\n//属性data2已加入监听器,现在值为:\"test\"\r\n//'test'\r\n```\r\n\r\n### 2.实现一个Dep与Watcher\r\n此时,我们定义的所有数据已经加入了监听,接下来我们需要实现一个Dep——订阅器，用来统一收集与管理订阅者.当属性变化时由它来通知所有的订阅者.显然,Dep应该是一个容器,我们就用List来实现吧.\r\n为了代码展示方便,我们新建一个Watcher文件,来存放 Dep与Wathcer的代码\r\n\r\n```js\r\nfunction Dep(){\r\n    this.subs = [];\r\n}\r\n\r\nDep.prototype = {\r\n    addSub : function(sub){\r\n        this.subs.push(sub);\r\n    },\r\n    notify:function(){\r\n        this.subs.forEach(sub=>{\r\n            sub.update();\r\n        })\r\n    }\r\n}\r\n```\r\n\r\n相应的，为了将监听器与订阅器连接起来，我们在需要在监听器中调用订阅器，将监听器的代码修改如下：\r\n\r\n```js\r\nfunction difineReactive(data,key,val){\r\n    obverve(val); //遍历所有子属性\r\n    var dep = new Dep();\r\n    Object.defineProperty(data,key,{\r\n        enumerable:true,\r\n        configurable:true,\r\n        get:function(){\r\n            if(是否需要添加Watcher){\r\n                dep.addSub(watcher); //添加订阅者\r\n            }\r\n            return val;\r\n        },\r\n        set:function(newVal){\r\n            val = newVal;\r\n            console.log('属性'+key+'已加入监听器,现在值为:\"'+newVal.toString()+'\"');\r\n            dep.notify(); //数据变化,通知所有订阅者\r\n        }\r\n    })\r\n}\r\n```\r\n\r\n这样,每次更新数据时,Set属性就会让Dep就会通知所有的Watcher.为了让Wathcer能够正常初始化,我们在Get属性中增加了初始化Watcher的功能,但很明显,总不能每次get都初始化一个Watcher吧,所有我们增加了条件判断来确定是否需要初始化Watcher.\r\n\r\n接下来我们来实现Watcher,  Watcher的代码写在Watcher文件中即可\r\n\r\n\r\n```js\r\nfunction Wathcher(myVM,exp,cb){\r\n    this.cb = cb;\r\n    this.vm = myVM;\r\n    this.exp = exp;\r\n    this.value = this.get(); //将自己添加到订阅器\r\n}\r\n\r\nWathcher.prototype = {\r\n    update : function(){\r\n        this.run();\r\n    },\r\n    run : function(){\r\n        var value = this.vm.data[this.exp];\r\n        var oldVal = this.value;\r\n        if(value !== oldVal){\r\n            this.value = value;\r\n            this.cb.call(this.vm,value,cb);\r\n        }\r\n    },\r\n    get: function(){\r\n        Dep.target = this; //将Watcher自身存入到target中缓存\r\n        var value = this.vm.data[this.exp]; //执行监听器中get函数\r\n        Dep.target = null; //释放自己\r\n        return value;\r\n    }\r\n}\r\n```\r\n这里的代码有一些抽象,需要我们仔细说一下:\r\n- Watcher中传入三个值: \r\n    - vm : 在代码执行环节会调用我们创建的vm实例(在本文中我们将会自己建一个简易的vm);\r\n    - exp : data中需要订阅者响应的数据(模板数据,在我们定义好解析器之前,暂时这个属性还未生效)\r\n    - cb : 回调函数,通常我们会在里面写入数据变化后在view中渲染页面的代码\r\n\r\nWatcher是如何运行的呢?\r\nWatcher初始化时去获取Observer中相应的值  →  Observer在Get中定义了添加Watcher的操作 → Wacher初始化时同时也将自己添加到Dep中\r\n前面我们提到,Observer不可能每一次出发get就要添加一个Watcher,所以增加了条件判断.我们使用一个缓存target来临时存放订阅者,添加成功后去掉即可.\r\n\r\n\r\n我们改造Observer如下:\r\n\r\n```js\r\nfunction obverve(data){\r\n    if(!data || typeof data !== 'object'){\r\n        return;\r\n    }\r\n    Object.keys(data).forEach(key=>{\r\n        difineReactive(data,key,data[key]);\r\n    })\r\n}\r\n\r\nfunction difineReactive(data,key,val){\r\n    obverve(val); //遍历所有子属性\r\n    var dep = new Dep();\r\n    Object.defineProperty(data,key,{\r\n        enumerable:true,\r\n        configurable:true,\r\n        get:function(){\r\n            if(Dep.target){\r\n                dep.addSub(watcher); //添加订阅者\r\n            }\r\n            return val;\r\n        },\r\n        set:function(newVal){\r\n            if(val === newVal){\r\n                return;\r\n            }\r\n            val = newVal;\r\n            console.log('属性'+key+'已加入监听器,现在值为:\"'+newVal.toString()+'\"');\r\n            dep.notify(); //数据变化,通知所有订阅者\r\n        }\r\n    })\r\n}\r\n```\r\n\r\n然后在Watcher中为Dep增加一个属性\r\n\r\n```js\r\nDep.target = null;\r\n```\r\n\r\n\r\nOK! 现在一个简单的Observer和Watcher(Dep) 已经构建完成了,我们只需要将他们关联起来即可. 这里我们还没有设计解析器Compile,所以还不能向Vue一样直接填入模板数据,我们咋们是暂时用一个写死模板数据来代替吧. \r\n\r\n新建一个Index.js  代码如下\r\n\r\n```js\r\nfunction MyVue (data,el,exp){\r\n    this.data = data;\r\n    obverve(data);\r\n    el.innerHTML = this.data[exp];\r\n    new Wathcher(this,exp,function(value){\r\n        el.innerHTML = value;\r\n    })\r\n    return this;\r\n}\r\n```\r\n\r\n在View层中调用\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>我的数据双向绑定系统</title>\r\n</head>\r\n<body>\r\n    <h1 id=\"name\">{{name}}</h1>\r\n</body>\r\n<script src=\"js/Index.js\"></script>\r\n<script src=\"js/Watcher.js\"></script>\r\n<script src=\"js/Observer.js\"></script>\r\n<script>\r\n    var ele = document.querySelector('#name');\r\n    var myVue = new MyVue(\r\n    {\r\n        name : 'hello world'\r\n    },\r\n    ele,'name');\r\n\r\n    console.log('当前的name:'+myVue.name);\r\n\r\n    window.setTimeout(()=>{\r\n        console.log('2000毫秒后,name值改变了');\r\n        myVue.data.name = 'hello me!'\r\n    },2000)\r\n</script>\r\n</html>\r\n```\r\n\r\n这样我们就新建了一个自己的Vue实例,在新建实例时传入数据,Observer遍历传入的数据,为其绑定Set和Get方法,之后为我们指定的 exp 属性建立Watcher来监听Observer传过来的数据变化消息.\r\n\r\n\r\n**截止现在,我们已经成功了一大半**\r\n\r\n![](https://www.xr1228.com//post-images/1591597132057.gif)\r\n\r\n这里我们再添加一个细节处理，我们修改data中数据需要通过这样的代码\r\n```\r\nmyVue.data.name = 'XXXXX'\r\n```\r\n但我们希望赋值代码是这样的\r\n```\r\nmyVue.name = 'XXXXX'\r\n```\r\n为了实现这样的效果,我们需要对myVue再做一个处理处理,将访问myVue属性代理为myVue.data.其实现原理也是通过Object.defineProtperty();  \r\n\r\n``\r\n\r\n让我们看一看效果:\r\n\r\n![](https://www.xr1228.com//post-images/1591608819475.PNG)\r\n\r\n注: 你可以点击这里获取源代码 [传送门](https://github.com/Wuriqilang/PlayGround/tree/master/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A)\r\n\r\n你也可以访问这个仓库,这个仓库将数据绑定的实现过程用不同版本代码展现出来了 [传送门](https://github.com/canfoo/self-vue/tree/master/v1)\r\n\r\n\r\n### 3.实现Compile\r\n\r\n我们已经实现了数据的双向绑定. 但是对于View层的渲染,我们采用的是这样的方式\r\n\r\n```html\r\n<h1 id=\"name\">{{name}}</h1>\r\n```\r\n```js\r\nvar ele = document.querySelector('#name');\r\nel.innerHTML = value;\r\n```\r\n这就导致我们定义的数据必须指定一个写死的 el(元素)来展示数据. 而Vue中这种数据是这样实现的:\r\n```html\r\n<h1>{{name}}</h1>\r\n```\r\n```js\r\n//js里根本不用写代码\r\n```\r\n\r\nVue这种数据同步的方式就是模板,为了实现模板语法,我们需要去实现一个解析器. 解析器解析dom节点,实现元素与数据的绑定.\r\n\r\n解析器工作有两个步骤:\r\n1. 解析模板指令,将其替换为模板数据,初始化View层\r\n2. 将模板指令对应的节点绑定对应的更新函数,初始化相关的订阅器\r\n\r\n\r\n首先定义一个解析器\r\n```js\r\nfunction Compile(el,vm){\r\n    this.vm = vm;\r\n    this.el = document.querySelector(el);\r\n    this.fragment = null;\r\n    this.init();\r\n}\r\n\r\n```\r\n\r\n为了解析模板首先需要获取dom元素,然后对dom元素上含有指令的节点进行处理. 因为这个环节需要对dom进行频繁操作,所以可以先建立一个fragment片段,将需要解析的节点存入fragment片段中:\r\n\r\n```js\r\nfunction nodeToFragment(el){\r\n    var fragment = document.createDocumentFragment();\r\n    var child = el.firstChild;\r\n    while(child){\r\n        //将Dom元素移入frament中\r\n        fragment.appendChild(child);\r\n        child = el.firstChild;\r\n    }\r\n    return fragment;\r\n}\r\n```\r\n\r\n接下来需要遍历每一个节点,将含有指令的节点进行处理. 我们先只考虑 '{{值}}' 这种情况:\r\n\r\n```js\r\nfunction Compile(el, vm) {\r\n  this.vm = vm;\r\n  this.el = document.querySelector(el);\r\n  this.fragment = null;\r\n  this.init();\r\n}\r\n\r\nCompile.prototype = {\r\n  init() {\r\n    if (this.el) {\r\n      this.fragment = this.nodeToFragment(this.el);\r\n      this.compileElement(this.fragment);\r\n      this.el.appendChild(this.fragment);\r\n    } else {\r\n      console.log(\"Dom元素不存在\");\r\n    }\r\n  },\r\n  nodeToFragment(el) {\r\n    var fragment = document.createDocumentFragment();\r\n    var child = el.firstChild;\r\n    while (child) {\r\n      //将Dom元素移入frament中\r\n      fragment.appendChild(child);\r\n      child = el.firstChild;\r\n    }\r\n    return fragment;\r\n  },\r\n\r\n  compileElement(el) {\r\n    var childNodes = el.childNodes;\r\n    var my = this;\r\n    [].slice.call(childNodes).forEach(node => {\r\n      var reg = /\\{\\{(.*)\\}\\}/;\r\n      var text = node.textContent;\r\n\r\n      if (my.isTextNode(node) && reg.test(text)) {\r\n        //判断是符合{{}}的指令\r\n        my.compileText(node, reg.exec(text)[1]);\r\n      }\r\n\r\n      if (node.childNodes && node.childNodes.length) {\r\n        my.compileElement(node); //继续递归遍历子节点\r\n      }\r\n    });\r\n  },\r\n\r\n  compileText(node, exp) {\r\n    var my = this;\r\n    var initText = this.vm[exp];\r\n    this.updateText(node, initText); //将初始化的数据初始化到视图中\r\n    new Watcher(this.vm, exp, function(value) {\r\n      my.updateText(node, value);\r\n    });\r\n  },\r\n\r\n  updateText(node, value) {\r\n    node.textContent = typeof value == \"undefined\" ? \"\" : value;\r\n  },\r\n  isTextNode: function(node) {\r\n    return node.nodeType == 3;\r\n  }\r\n};\r\n\r\n```\r\n\r\n这个时候我们将index中的代码稍作修改，去掉手动添加Watcher的操作，让解析器自己在 id=app的div中遍历递归查找所有'{{值}}' 的模板指令吧。\r\n\r\n```js\r\n//index.js\r\nfunction MyVue(options) {\r\n  var my = this;\r\n  this.vm = this;\r\n  this.data = options.data;\r\n\r\n  Object.keys(this.data).forEach(function(key) {\r\n    my.proxyKeys(key); //绑定代理属性\r\n  });\r\n\r\n  obverve(this.data);\r\n  // el.innerHTML = this.data[exp];\r\n  // new Wathcher(this,exp,function(value){\r\n  //     el.innerHTML = value;\r\n  // })\r\n  new Compile(options.el, this.vm);\r\n  return this;\r\n}\r\n\r\nMyVue.prototype = {\r\n  proxyKeys(key) {\r\n    var my = this;\r\n    Object.defineProperty(this, key, {\r\n      enumerable: false,\r\n      configurable: true,\r\n      get: function proxyGetter() {\r\n        return my.data[key];\r\n      },\r\n      set: function proxySetter(newVal) {\r\n        my.data[key] = newVal;\r\n      }\r\n    });\r\n  }\r\n};\r\n```\r\nhtml也要做相应的修改（有Vue的味道了）\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>我的数据双向绑定系统</title>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"app\">\r\n        <h2>{{title}}</h2>\r\n        <h1>{{name}}</h1>\r\n    </div>\r\n\r\n</body>\r\n<script src=\"js/Watcher.js\"></script>\r\n<script src=\"js/Observer.js\"></script>\r\n<script src=\"js/Compile.js\"></script>\r\n<script src=\"js/Index.js\"></script>\r\n<script>\r\n    var myVue = new MyVue({\r\n        el: '#app',\r\n        data:{\r\n            title: 'Compile is Working!',\r\n            name: ''\r\n        }\r\n    });\r\n\r\n    console.log('当前的name:' + myVue.name);\r\n\r\n    window.setTimeout(() => {\r\n        console.log('2000毫秒后,name值改变了');\r\n        myVue.title = 'hello me!'\r\n    }, 2000)\r\n</script>\r\n\r\n</html>\r\n```\r\n\r\n到这里，我们就会发现以前vue的一些设定的来源，譬如为什么vue的html需要包裹在一个div中，譬如什么声明vue实例时会有一个 el = '#app' 。\r\n\r\n接下来我们完善解析器，使其能够判断更多的指令. (例如: v-    on: 等指令);\r\n\r\n首先将 compile的compileElement 方法进行改造\r\n\r\n```js\r\n  compileElement(el) {\r\n    var childNodes = el.childNodes;\r\n    var my = this;\r\n    [].slice.call(childNodes).forEach(node => {\r\n      var reg = /\\{\\{(.*)\\}\\}/;\r\n      var text = node.textContent;  //获取node中内容\r\n\r\n      if(my.isElementNode(node)){  //如果是node属性中的指令\r\n        self.compile(node); //node属性指令调用compile来解析\r\n      }\r\n      else if (my.isTextNode(node) && reg.test(text)) {  //如果是模板指令\r\n        //判断是符合{{}}的指令\r\n        my.compileText(node, reg.exec(text)[1]);\r\n      }\r\n      \r\n      if (node.childNodes && node.childNodes.length) {\r\n        my.compileElement(node); //继续递归遍历子节点\r\n      }\r\n    });\r\n  }\r\n\r\n  //判断是否是node属性中的指令\r\n    isElementNode:function(node){\r\n    return node.nodeType == 1;\r\n  }\r\n  ```\r\n\r\n  接下来我们来编写compile方法,使其可以解析不同指令. 这部分就不详细说明了, 直接看一下代码.\r\n  ```js\r\n  function Compile(el, vm) {\r\n  this.vm = vm;\r\n  this.el = document.querySelector(el);\r\n  this.fragment = null;\r\n  this.init();\r\n}\r\n\r\nCompile.prototype = {\r\n  init() {\r\n    if (this.el) {\r\n      this.fragment = this.nodeToFragment(this.el);\r\n      this.compileElement(this.fragment);\r\n      this.el.appendChild(this.fragment);\r\n    } else {\r\n      console.log(\"Dom元素不存在\");\r\n    }\r\n  },\r\n  nodeToFragment(el) {\r\n    var fragment = document.createDocumentFragment();\r\n    var child = el.firstChild;\r\n    while (child) {\r\n      //将Dom元素移入frament中\r\n      fragment.appendChild(child);\r\n      child = el.firstChild;\r\n    }\r\n    return fragment;\r\n  },\r\n\r\n  compileElement(el) {\r\n    var childNodes = el.childNodes;\r\n    var my = this;\r\n    [].slice.call(childNodes).forEach(node => {\r\n      var reg = /\\{\\{(.*)\\}\\}/;\r\n      var text = node.textContent;  //获取node中内容\r\n\r\n      if (my.isElementNode(node)) {  //如果是node属性中的指令\r\n        my.compile(node); //node属性指令调用compile来解析\r\n      }\r\n      else if (my.isTextNode(node) && reg.test(text)) {  //如果是模板指令\r\n        //判断是符合{{}}的指令\r\n        my.compileText(node, reg.exec(text)[1]);\r\n      }\r\n\r\n      if (node.childNodes && node.childNodes.length) {\r\n        my.compileElement(node); //继续递归遍历子节点\r\n      }\r\n    });\r\n  },\r\n  compile(node) {\r\n    var nodeAttrs = node.attributes;\r\n    var my = this;\r\n    Array.prototype.forEach.call(nodeAttrs, attr => {\r\n      var attrName = attr.name;\r\n      if (my.isDirective(attrName)) {\r\n        var exp = attr.value;\r\n        var dir = attrName.substring(2);\r\n        if (my.isEventDirective(dir)) {  //事件指令\r\n          my.compileEvent(node, my.vm, exp, dir);\r\n        } else {  //v-mode 指令\r\n          my.compileModel(node, my.vm, exp, dir);\r\n        }\r\n        node.removeAttribute(attrName);\r\n      }\r\n    })\r\n  },\r\n  compileText(node, exp) {\r\n    var my = this;\r\n    var initText = this.vm[exp];\r\n    my.updateText(node, initText); //将初始化的数据初始化到视图中\r\n    new Watcher(this.vm, exp, function (value) {\r\n      my.updateText(node, value);\r\n    });\r\n  },\r\n  compileEvent: function (node, vm, exp, dir) {\r\n    var eventType = dir.split(':')[1];\r\n    var cb = vm.methods && vm.methods[exp];\r\n\r\n    if (eventType && cb) {\r\n      node.addEventListener(eventType, cb.bind(vm), false);\r\n    }\r\n  },\r\n  compileModel: function (node, vm, exp, dir) {\r\n    var my = this;\r\n    var val = this.vm[exp];\r\n    this.modelUpdater(node, val);\r\n    new Watcher(this.vm, exp, function (value) {\r\n      my.modelUpdater(node, value);\r\n    })\r\n\r\n    node.addEventListener('input', function (e) {\r\n      var newValue = e.target.value;\r\n      if (val === newValue) {\r\n        return;\r\n      }\r\n      my.vm[exp] = newValue;\r\n      val = newValue;\r\n    })\r\n  },\r\n  modelUpdater: function (node, value, oldValue) {\r\n    node.value = typeof value == 'undefined' ? '' : value;\r\n  },\r\n  //是否为v-model指令\r\n  isDirective: function (attr) {\r\n    return attr.indexOf('v-') == 0;\r\n  },\r\n  //是否为事件指令\r\n  isEventDirective: function (dir) {\r\n    return dir.indexOf('on:') === 0;\r\n  },\r\n\r\n\r\n  updateText(node, value) {\r\n    node.textContent = typeof value == \"undefined\" ? \"\" : value;\r\n  },\r\n  //判断是否为testNode类型\r\n  isTextNode: function (node) {\r\n    return node.nodeType == 3;\r\n  },\r\n  //判断是否是node属性中的指令\r\n  isElementNode: function (node) {\r\n    return node.nodeType == 1;\r\n  }\r\n};\r\n\r\n```\r\n这部分代码还请查看原作者的github  [传送门](https://github.com/canfoo/self-vue/tree/master/v3)\r\n\r\n接下里我们对index文件进行改造,使其具有 methdos的属性,可以执行mounted函数\r\n\r\n```js\r\nfunction MyVue(options) {\r\n  var my = this;\r\n  this.data = options.data;\r\n  this.methods = options.methods;\r\n\r\n  Object.keys(this.data).forEach(function(key) {\r\n    my.proxyKeys(key); //绑定代理属性\r\n  });\r\n\r\n  obverve(this.data);\r\n  // el.innerHTML = this.data[exp];\r\n  // new Wathcher(this,exp,function(value){\r\n  //     el.innerHTML = value;\r\n  // })\r\n  new Compile(options.el, this);\r\n  options.mounted.call(this); //所有事情处理好后执行mounted函数\r\n}\r\n```\r\n\r\nOK! 大功告成!!!!  我们测试一下吧\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>我的数据双向绑定系统</title>\r\n</head>\r\n\r\n<body>\r\n    <div id=\"app\">\r\n        <h1>{{title}}</h1>\r\n        <h2>{{name}}</h2>\r\n        <input v-mode=\"keywords\"></input>\r\n        <select v-mode=\"keywords\">\r\n            <option value=\"volvo\">Volvo</option>\r\n            <option value=\"saab\">Saab</option>\r\n            <option value=\"mercedes\">Mercedes</option>\r\n            <option value=\"audi\">Audi</option>\r\n        </select>\r\n        <h2>{{keywords}}</h2>\r\n        <button v-on:click=\"clickMe\">click me!</button>\r\n    </div>\r\n\r\n</body>\r\n<script src=\"js/Watcher.js\"></script>\r\n<script src=\"js/Observer.js\"></script>\r\n<script src=\"js/Compile.js\"></script>\r\n<script src=\"js/Index.js\"></script>\r\n<script>\r\n    new MyVue({\r\n        el: '#app',\r\n        data: {\r\n            title: 'Title',\r\n            name: 'Wuriqilang',\r\n            keywords:'myVue'\r\n        },\r\n        mounted(){\r\n            window.setTimeout(() => {\r\n                console.log('2000毫秒后,title值改变了');\r\n                this.title = 'Compile is Working!'\r\n            }, 2000)\r\n\r\n\r\n            window.setTimeout(() => {\r\n                console.log('5000毫秒后,name值改变了');\r\n                this.name = 'you complete it!Congratulation!'\r\n            }, 5000)\r\n        },\r\n        methods:{\r\n            clickMe(){\r\n                this.title = 'i click the button!'\r\n            }\r\n        }\r\n    });\r\n</script>\r\n\r\n</html>\r\n```\r\n![](https://www.xr1228.com//post-images/1591755182754.PNG)\r\n\r\n接下来,我们发挥切图仔的功力,对这个页面样式做一个简单的美化吧.\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=0, initial-scale=1.0\">\r\n    <title>我的数据双向绑定系统</title>\r\n    <style>\r\n        html{height:100%}\r\n        body{\r\n            height:100%;\r\n            display:flex;\r\n            justify-content : center;  \r\n            align-items : center;   \r\n        }\r\n        #app{\r\n            text-align: center;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"app\">\r\n        <img src=\"./assest/image/logo.png\" alt=\"logo\">\r\n        <h1>{{title}}</h1>\r\n        <h2>{{name}}</h2>\r\n        <input v-mode=\"keywords\"></input>\r\n        <select v-mode=\"keywords\">\r\n            <option value=\"volvo\">Volvo</option>\r\n            <option value=\"saab\">Saab</option>\r\n            <option value=\"mercedes\">Mercedes</option>\r\n            <option value=\"audi\">Audi</option>\r\n        </select>\r\n        <h2>{{keywords}}</h2>\r\n        <button v-on:click=\"clickMe\">click me!</button>\r\n    </div>\r\n</body>\r\n<script src=\"js/Watcher.js\"></script>\r\n<script src=\"js/Observer.js\"></script>\r\n<script src=\"js/Compile.js\"></script>\r\n<script src=\"js/Index.js\"></script>\r\n<script>\r\n    new MyVue({\r\n        el: '#app',\r\n        data: {\r\n            title: 'Title',\r\n            name: 'Wuriqilang',\r\n            keywords:'myVue'\r\n        },\r\n        mounted(){\r\n            window.setTimeout(() => {\r\n                console.log('2000毫秒后,title值改变了');\r\n                this.title = 'Compile is Working!'\r\n            }, 2000)\r\n\r\n\r\n            window.setTimeout(() => {\r\n                console.log('5000毫秒后,name值改变了');\r\n                this.name = 'you complete it!Congratulation!'\r\n            }, 5000)\r\n        },\r\n        methods:{\r\n            clickMe(){\r\n                this.title = 'i click the button!'\r\n            }\r\n        }\r\n    });\r\n</script>\r\n</html>\r\n```\r\n以下是最终效果:\r\n\r\n![](https://www.xr1228.com//post-images/1591757508655.gif)\r\n\r\n",
      "data": {
        "title": "【前端拾遗】不写一遍总是记不住——Vue数据双向绑定",
        "date": "2020-06-05 16:22:23",
        "tags": [
          "vue",
          "前端拾遗"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/databind.PNG",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "数据双向绑定，作为三大前端框架的重要特性，总是被人们津津乐道（尤其是面试官），defineProperty啦，proxy啦，digest循环检查啦（AngularJS）……数据绑定的相关文章看了很多，但总是感觉差点意思,还是自己亲自实现一个数据绑定吧\r",
      "fileName": "databind"
    },
    {
      "content": "今天来说一个很基础但是很实用的Html功能，以及很多前端面试中要考察的基础内容 —— meta标签。\n\n<!-- more -->\n\n直接切入正题，meta标签是非常有用的辅助性标签，所有浏览器都能识别它。meta标签的内容并不会显示出来，但是会被浏览器识别。浏览器识别meta数据是将其识别为“metadata”（中文范围为元数据，但我觉得词不达意，容易造成误解，我们就仍旧沿用其英文名称“metadata”）\n\n> The <meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.\n\nmeta标签通常被用来定义页面的说明，关键字，修改时间等。meta标签中的信息给浏览器或搜索引擎以实现一些特定功能。\n\n> Meta elements are typically used to specify page description, keywords, author of the document, last modified, and other metadata.\n\n需要说明的是，meta标签是通过name与content来定义metadata数据的，所以说metadata是一种“名值对”的数据。\n\nmeta有两个属性：\n- name：用于描述网页，它是metadata“名值对”数据中的“名”，name属性确定需要描述的项目后，content填入其具体描述。\n- http-equiv：equivalent是“相当于”的意思，http-equiv相当于http文件头，其定义项会加入到http请头中，实现一些特定的效果。\n\n那么，meta有哪些好的应用场景呢？（本文仅会对常用的meta属性进行说明与列举，力求以解决问题为主要目的，如果想了解更多，请穿越这座传送门：[html头部meta标签汇总](https://www.jianshu.com/p/8d28e5130ab2)\n\n## 1.移动端适配\n```html\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1\">\n```\n解释一下：\n- viewport 是指 web 页面上用户的可见区域。\n- width=device-width 是指css像素等于设备最佳像素（即占满屏幕），不同设备的divice-width是不同的\n- initial-scale=1 是指初始缩放比例\n- initial-scale=1.0 是指初始化的时候缩放大小是1，也就是不缩放。\n- user-scalable=0 是指禁止用户进行缩放。\n- maximum-scale=1.0 是指用户最大缩放大小是1，其实在禁止用户缩放以后，这一句可以省略。\n\n\n通常来说我们了解这些就绰绰有余了，但是这里引出了一个重要的概念：CSS像素。我觉得有责任把这个meta的实现原理说清楚，先明确几个概念：\n- **设备像素 / 物理像素（physical pixels）**\n是指屏幕的实际物理像素点，比如普通的1080P手机是 1920*1080 的像素分辨率，那么代表它纵向有 1920 个物理像素点，横向有 1080 个物理像素点。\n- **CSS 像素（css pixel） / 密度独立像素（density independent pixels - dip）**\nCSS 像素是 web 编程中的概念，是抽象的，不是实际存在的。它是独立于设备用于逻辑上衡量像素的单位，所以又叫密度独立像素。dip 有时候也缩写为 dp 。\n屏幕尺寸\n指屏幕的对角线长度，单位是英寸（inch），1 英寸 = 2.54 厘米。常见屏幕尺寸有 5.0、5.5 和 6.0 等。\n- **屏幕像素密度（pixels per inch - ppi）**\n指屏幕上每英寸可以显示的物理像素点的数量。比如 iPhone6 Plus 是 5.5 英寸，分辨率（也就是物理像素）是 1920*1080 像素，那么它的 ppi = √(19202+10802) / 5.5 ≈ 401ppi 。也就是说它每英寸可以显示 440 个物理像素点。\n- **设备像素比**\n指物理像素和密度独立像素的比值。\nwindow.devicePixelRatio = 物理像素 / dip。\n可以通过 window.devicePixelRatio 获得，该属性被所有WebKit浏览器以及Opera所支持。\n\n譬如iphone6（虽然过时了，但是这个例子最经典），他的硬件宽度是750个像素，device-width是375像素，所以我们在css将宽度定义为375px时就占满屏幕了，这就是我们经常听说的“二倍图”\n这个时候，前端开发时候如果按照设计图（设计图通常是PC端）中给出的尺寸在移动端定义一张图片的宽度，其真实宽度就会放大二倍，从而产生失真。\n\n## 2.网页内容说明\n我们可以将网页的主要内容进行定义，提供给搜索引擎，便于SEO。\n```html\n//标题\n<meta name=\"title\" content=\"优酷-这世界很酷\" />\n//关键词\n<meta name=\"keywords\" content=\"视频,视频分享,视频搜索,视频播放\" />\n//描述\n<meta name=\"description\" content=\"京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，<br>为您提供愉悦的网上购物体验!\" />\n//作者\n<meta name = \"author\" content = \"Wuriqilang\" />\n//版权信息\n<meta name=\"copyright\" content=\"本页版权 www.qidian.com 起点中文网所有。All Rights Reserved\" />\n```\n\n注意这里title,keywords,descripiton几个属性对于搜索引擎来说权重是逐渐减小的。\n至于这几个属性在搜索引擎中优化SEO的原理那就又是一个故事了,以后有空时候可以聊一聊.\n\n\n## 3.字体编码\n字体编码这个属性就像纸质现金,它很重要,在以前最重要,但是随着在线支付的兴起,它仍旧很重要,但是人们不再需要时刻都把它带在身上了.\n我们知道字体编码是用来规范html文档编码的就行了\n```html\n<meta charset=\"UTF-8\">\n```\n\n## 4.禁止识别数字为电话号码\n\n\n```html\n<meta name=\"format-detection\" content=\"telephone=no\" />  \n```\n\n## 5.指定渲染内核(有些国产浏览器会使用双核)\n```html\n<meta name=\"renderer\" content=\"webkit\">\n```\n\n\n本文仅会对常用的meta属性进行说明与列举，力求以解决问题为主要目的，如果想了解更多，请穿越这座传送门：[html头部meta标签汇总](https://www.jianshu.com/p/8d28e5130ab2)\n",
      "data": {
        "title": "【前端拾遗】很基础,但很实用——Meta标签",
        "date": "2020-06-02 16:28:17",
        "tags": [
          "前端拾遗"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/meta.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "今天来说一个很基础但是很实用的Html功能，以及很多前端面试中要考察的基础内容 —— meta标签。",
      "fileName": "meta"
    },
    {
      "content": "除了数据双向绑定、virtual Dom等偏向于底层实现的知识点外，vue的生命周期函数作为应用层层面里最核心的问题，其重要程度随着你的能力提升会不断提高。\n\n\n<!-- more -->\n## 1.定义\n  每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n\n![](https://www.xr1228.com//post-images/1590975920584.png)\n\n|  生命周期钩子   | 组件状态  | 最佳实践 |\n|  ----  | ----  | ---- |\n| beforeCreate  | 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methdos上的方法和数据 | 常用于初始化非响应式变量 |\n| created | 实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问\\$el属性，\\$ref属性内容为空数组 | 常用于简单的ajax请求，页面的初始化 |\n| beforeMount | 在挂载开始之前被调用，beforeMount之前，会找对对应的template，并编译成render函数 | - |\n| mounted | 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，/$ref属性可以访问 | 常用于获取VNode信息和操作，ajax请求 |\n|beforeupdate | 响应式数据更新时调用，发生在虚拟DOM打补丁之前 | 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 |\n| updated | 虚拟DOM重新渲染和补丁之后调用，组件DOM已经更新，可以执行依赖于DOM的操作 | 避免在这个钩子函数中操作数据，可能陷入死循环 |\n| beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 | 常用于销毁定时器、解绑全局事件、销毁插件对象等操作 |\n| destroyed | 实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 | - |\n\n注意：\n- created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，会导致页面长时间处于白屏状态。\n\n接下来我们从流程和代码两个方面来说明Vue的生命周期：\n\n## 2.Vue生命周期流程\n\n1. 当我们创建一个Vue实例，即new Vue()，首先会执行init函数，在init函数中会执行第一个 beforeCreated钩子函数。\n    - 执行beforeCreate之前，先执行mergeOptions函数，得到/$options选项，并把这个设置成Vue实例的一个属性。\n    - beforeCreate，设个阶段生成生命周期以及一些数据的初始化。\n2. 接下来执行created：这个阶段数据已经绑定在实例上，但是还没有挂载对象。\n3. created之后，判断instance（实例）是否含有'el'这个options选项。\n   - 如果没有，它会调用vm./$mount(el) 这个方法，然后执行下一步，意味着它会停止编译，生命周期结束。\n   - 如果有，判断是否含有template属性，如果有的话Vue将template解析成一个render function，如果没有template选项它将外部的HTML作为模板编译。\n4. 当render function之后才会执行beforeMounted，\n\n这里说的不明白， 以后重写\n\n\n## 3. 单个组件的生命周期\n```html\n<template>\n  <div id='single'>\n      <h3>单个组件的生命周期函数</h3>\n      <button @click=\"singleData+= 1\">更新{{singleData}}</button>\n      <button @click=\"handleDestroy\">销毁</button>\n  </div>\n</template>\n\n<script>\nexport default {\n    data(){\n        return{\n            singleData:1\n        }\n    },\n    //生命周期\n    beforeCreate(){\n        this.compName = 'single';  //定义非响应式变量\n        console.log(`--${this.compName}--befroeCreate`);\n    },\n    created() {\n        console.log(`--${this.compName}--created`)\n    },\n    beforeMount() {\n        console.log(`--${this.compName}--beforeMount`)\n    },\n    mounted() {\n        console.log(`--${this.compName}--mounted`)\n    },\n    beforeUpdate() {\n        console.log(`--${this.compName}--beforeUpdate`)\n    },\n    updated() {\n        console.log(`--${this.compName}--updated`)\n    },\n    beforeDestroy() {\n        console.log(`--${this.compName}--beforeDestroy`)\n    },\n    destroyed() {\n        console.log(`--${this.compName}--destroyed`)\n    },\n    methods:{\n        handleDestroy(){\n            this.$destroy();\n        }\n    }\n}\n</script>\n```\n\n当组件加载与初始化时：\n\n![](https://www.xr1228.com//post-images/1590979391076.PNG)\n\n当更新组件时：\n\n> --single--beforeUpdate\n> --single--updated\n\n组件销毁时：\n\n> --single--beforeDestroy\n> --single--destroyed\n\n\n从结果我们可以看出： \n\n1. 初始化组件时，仅执行了beforeCreate/Created/beforeMount/mounted四个钩子函数\n2. 当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数\n3. 当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数\n4. **初始化和销毁时的生命钩子函数均只会执行一**次，beforeUpdate/updated可多次执行\n\n## 4.父子组件之间传值\n\n\n父组件：\n```html\n<template>\n  <div id='father'>\n    <button @click=\"handleDestroy\">父组件销毁</button>\n    <child compName='child'></child>\n  </div>\n</template>\n\n<script>\nimport  child  from \"../components/Child.vue\";\nexport default {\n  name:'Father',\n  components: {\n     child\n  },\n    //生命周期\n    beforeCreate() {\n    this.compName = 'father';  //定义非响应式变量\n    console.log(`--${this.compName}--befroeCreate`);\n  },\n  created() {\n    console.log(`--${this.compName}--created`)\n  },\n  beforeMount() {\n    console.log(`--${this.compName}--beforeMount`)\n  },\n  mounted() {\n    console.log(`--${this.compName}--mounted`)\n  },\n  beforeUpdate() {\n    console.log(`--${this.compName}--beforeUpdate`)\n  },\n  updated() {\n    console.log(`--${this.compName}--updated`)\n  },\n  beforeDestroy() {\n    console.log(`--${this.compName}--beforeDestroy`)\n  },\n  destroyed() {\n    console.log(`--${this.compName}--destroyed`)\n  },\n  methods: {\n    handleDestroy() {\n      this.$destroy();\n    }\n  }\n}\n</script>\n```\n子组件：\n```html\n<template>\n  <div id='child'>\n      <h3>单个组件的生命周期函数</h3>\n      <button @click=\"singleData+= 1\">更新{{singleData}}</button>\n      <button @click=\"handleDestroy\">销毁</button>\n  </div>\n</template>\n\n<script>\nexport default {\n    name:'child',\n    props:{\n        compName:String\n    },\n    data(){\n        return{\n            singleData:1\n        }\n    },\n    //生命周期\n    beforeCreate(){\n        //this.compName = 'single';  //定义非响应式变量\n        console.log(`--props的值未获取，不知道compName是啥--befroeCreate`);\n    },\n    created() {\n        console.log(`--${this.compName}--created`)\n    },\n    beforeMount() {\n        console.log(`--${this.compName}--beforeMount`)\n    },\n    mounted() {\n        console.log(`--${this.compName}--mounted`)\n    },\n    beforeUpdate() {\n        console.log(`--${this.compName}--beforeUpdate`)\n    },\n    updated() {\n        console.log(`--${this.compName}--updated`)\n    },\n    beforeDestroy() {\n        console.log(`--${this.compName}--beforeDestroy`)\n    },\n    destroyed() {\n        console.log(`--${this.compName}--destroyed`)\n    },\n    methods:{\n        handleDestroy(){\n            this.$destroy();\n        }\n    }\n}\n</script>\n```\n初始化组件时，打印：\n> --father--befroeCreate\n> --father--created\n> --father--beforeMount\n> --props的值未获取，不知道compName是啥--befroeCreate\n> --child--created\n> --child--beforeMount\n> --child--mounted\n> --father--mounted\n数据更新时\n> child--beforeUpdate\n> --child--updated\n组件销毁时\n> --father--beforeDestroy\n> --child--beforeDestroy\n> --child--destroyed\n> --father--destroyed\n\n从打印结果可以看出:\n\n1. 仅当子组件完成挂载后，父组件才会挂载\n2. 当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）\n3. 父子组件在data变化中是分别监控的，但是在更新props中的数据是关联的（可实践）\n4. 销毁父组件时，先将子组件销毁后才会销毁父组件\n\n",
      "data": {
        "title": "【前端拾遗】VUE的生命周期函数——详解",
        "date": "2020-06-01 09:38:11",
        "tags": [
          "前端拾遗",
          "vue"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/vuelivecycle.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "除了数据双向绑定、virtual Dom等偏向于底层实现的知识点外，vue的生命周期函数作为应用层层面里最核心的问题，其重要程度随着你的能力提升会不断提高。",
      "fileName": "vuelivecycle"
    },
    {
      "content": "数据结构是一切算法的基础,作为一个以解决问题为目的的工程师,在本文将会列举几种你一定会用到的数据结构,并尽量从实际出发来说明其作用.  \n至于复杂高级的数据结构,不是我们关注的重点,也不会出现在未来可能出现的面试当中.\n\n# 1.数组 : 你知道它,用它,但未必懂它\n\n数组(Array)是一种**线性表**数据结构.它用一组**连续的内存空间**,来存储一组具有**相同类型的数据**\n\n这句话其实很简单,我们来说明一下几个关键词.\n\n**线性表** : 顾名思义,线性表就是将数据排成像一条线一样的结构.每个线性表上的数据都是前后关系. 除了数组之外,链表、队列、栈等也是线性表结构。\n\n\n![](https://www.xr1228.com//post-images/1590659062451.jpg)\n\n\n> 与它相对立的概念是**非线性表**，比如二叉树、堆、图等。在非线性表中，数据之间不是简单的前后关系\n\n![](https://www.xr1228.com//post-images/1590659144195.jpg)\n\n\n**连续的内存空间和相同类型的数据**：数组的这个特点使其具有了“随机访问”的能力。但是这也样数组的插入、删除变得非常低效。毕竟它是连续的数据，每一次插入和删除都需要对大量数据做移动。\n\n\n因为是整个系列的第一个数据类型，我认为花一些篇幅来讲讲数据结构在内存中的实现是值得的。\n\n1. 当我们定义一个数组时，计算机会开辟一块空间用于存放数组。\n2. 计算机会为每一个内存单元（数组中的每一项）分配一个地址，计算机就可以通过这个地址来访问内存中的数据。\n\n譬如我们新建了一个int类型的数组   int[] a = new int[10] ; 这个数组中每一项都是int类型，int类型数据大小为4个字节。所以计算机通过计算，开辟了40个字节的空间。计算机开辟的这个空间我们称之为内存块，假设这个内存块的首地址为 base_address = 1000\n\n![](https://www.xr1228.com//post-images/1590660142685.jpg)\n\n数据空间开辟好后，计算机访问其中某一个内存单元时，只要计算出其内存地址即可：\n\n```js\na[i]_address = base_address + i * data_type_size;\n```\n所以当我们需要通过下标来访问呢数组中的某一项时，时间复杂度为O(1)。这也是数组为什么使用如此广泛的原因。\n\n但当我们需要插入或者删除时，简直是一场灾难。加入一个数组中5各项，在第一项插入一个值就需要把**每一项向后移动一位**\n\n当然，当我们不追求数组的顺序时其实是有其他方式降低插入和删除消耗的，我们暂时不用了解。\n\n# 2.链表\n\n- 链表：**通过指针将一组零散的内存数据串联在一起，这样的数据结构就是链表**。其中的内存块我们称之为“**节点**“，节点中除了存储数据之外，还存储了指向与这个节点相连的节点的地址，我们将记录节点地址称之为**指针**\n\n相对于数组，链表显得稍微复杂。\n![](https://www.xr1228.com//post-images/1590740821745.jpg)\n\n数组中的数据单元都是连续的，但链表并不需要申请大块的连续的内存空间，哪里有空插哪里，只需要通过指针把这些数据组织起来即可。\n\n链表结构有很多种类型，最常用的就是三种：单链表、双链表、循环链表。\n\n![](https://www.xr1228.com//post-images/1590741026478.jpg)\n\n![](https://www.xr1228.com//post-images/1590741050687.jpg)\n\n![](https://www.xr1228.com//post-images/1590741076134.jpg)\n\n与数组一样，链表也支持数据的查找、插入和删除操作。\n\n- 查找：链表的内存地址并不是连续的，我们无法通过头节点计算出所需的数据地址，需要从头节点开始不断查询到我们所需的内存单元。时间复杂度为O(n)\n- 插入和删除：链表的插入和删除就无需像数组一样进行大量的数据搬迁，只需要考虑相邻节点即可。时间复杂度为O(1)\n\n![](https://www.xr1228.com//post-images/1590741326297.jpg)\n\n### 链表有什么用？\n\n我们学习一门技术，本质上就是为了解决问题，那么在实践应用中链表解决了什么问题呢？\n\n> 链表能够完美的契合LRU缓存淘汰算法。\n\n![](https://www.xr1228.com//post-images/1590889060715.gif)\n\n啥？啥是LRU？所谓LRU淘汰算法就一种提高数据读取性能的技术，在硬件设计与软件开发中使用非常广泛。譬如CPU缓存、数据库缓存、浏览器缓存等。缓存大小是有限的，当我们缓存被沾满时，那些数据应该清除，那些数据应该保留？ That is a Question。\n\nLRU缓存淘汰算法（最近最少使用策略）就是用来进行这项工作的：比如说你有很多书籍，书架放不下了，必须清除一些书籍，你筛选书籍是不是这样的策略呢？那么如何用链表实现LRU算法呢？\n\n我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。\n1. 当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。\n2. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。\n3. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。这样我们就用链表实现了一个 LRU 缓存，是不是很简单？\n\n### 链表的实现：\n链表基础知识确实也很容易掌握，但写好链表并实现相关的操作很少有人能做到。为了能够不要眼高手低，写出靠谱的链表代码，我们需要注意以下几点：\n\n1. 理解指针或引用的含义\n很多语言并没有**指针**的概念，取而代之的是**引用**，譬如Java、Python、JS。你将引用理解为指针即可，他们都是存储了对象的内存地址。\n\n**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**\n\n2.警惕指针丢失与内存泄露\n写链表的时候很容易出现指针指来指去最后不知道指导哪里去了。为什么会丢失指针呢？\n\n![](https://www.xr1228.com//post-images/1590742103042.jpg)\n\n```c\np->next = x; // 将p的next指针指向x结点；\nx->next = p->next; // 将x的结点的next指针指向b结点；\n```\n如果我们这样写代码，p的指针已经指向到x节点了，再来设置x的指针时，等于将X的指针指向自己。就导致链表断开，内存泄露，指针丢失。\n解决这个问题很简单，只要把代码顺序调换一下即可\n```c\nx->next = p->next; // 将x的结点的next指针指向b结点；\np->next = x; // 将p的next指针指向x结点；\n```\n3. 重点留意边界条件处理\n\n我经常用来检查链表代码是否正确的边界条件有这样几个：\n- 如果链表为空时，代码是否能正常工作？\n- 如果链表只包含一个结点时，代码是否能正常工作？\n- 如果链表只包含两个结点时，代码是否能正常工作？\n- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？\n\n\n啰里啰唆的说了半天，对于我们解决问题为首要目的的工程师来说稍显多余。我们直接来实现一个链表，采用的语言就使用地球上使用人数最多的语言 JS吧。\n\n### 单项链表的设计：\n\n根据之前的链表原理，链表包括两个类：一个是Node类来表示节点，一个是LinkedList类表示链表，并且提供链表插入、删除、查找的操作。\n\n- Node类\nNode类包括两个属性：element来保存节点上的数据，next来保存下一个节点的地址：\n```js\nfunction Node(element){\n    this.element = element ; //当前节点中存储的内容\n    this.next = null; //下一个节点链接\n}\n```\n- LinkedList类\nLinkedList类提供了对链表进行操作的方法，包括插入删除节点，查找给定的值等。值得注意的是，它只有一个 属性，那就是使用一个 Node 对象来保存该链表的头节点。\n\n```js\nfunction Node(element) {\n  this.element = element; //当前节点中存储的内容\n  this.next = null; //下一个节点链接\n}\n\nfunction LinkedList() {\n  this.head = new Node(\"head\"); //头节点\n  this.find = find; //查找节点\n  this.insert = insert; //插入节点\n  this.remove = remove; // 删除节点\n  this.findPrev = findPrev; // 查找前一个节点\n  this.display = display; // 显示链表\n  //查找\n  function find(item) {\n    var currNode = this.head;\n    while (currNode.element != item) {\n      currNode = currNode.next;\n    }\n    return currNode;\n  }\n  //插入\n  function insert(newElement, item) {\n    var newNode = new Node(newElement);\n    var currNode = this.find(item);\n    newNode.next = currNode.next;\n    currNode.next = newNode;\n  }\n  //显示\n  function display() {\n    var currNode = this.head;\n    while (!(currNode.next == null)) {\n      console.log(currNode.next.element);\n      currNode = currNode.next;\n    }\n  }\n  //删除\n  function remove(item) {\n    //删除节点需要找到需要删除的节点与上一个节点\n    var removeNode = this.find(item);\n    var prevNode = this.findPrev(removeNode);\n    prevNode.next = removeNode.next;\n  }\n  //查找上一个节点\n  function findPrev(node) {\n    var prevNode = this.head;\n    while (prevNode.next != node) {\n      prevNode = prevNode.next;\n    }\n    return prevNode;\n  }\n}\n```\n我们可以调用测试一下：\n```js\nvar demo = new LinkedList();\n\ndemo.insert(\"first\", \"head\");\ndemo.insert(\"second\", \"first\");\ndemo.insert(\"third\", \"second\");\ndemo.display();\n//first\n//second\n//third\n\ndemo.remove(\"second\");\ndemo.display();\n//first\n//third\n\n```\n如果你想彻底掌握链表，应对面试中出现的各位问题，那就需要多写多练，熟能生巧。对于双向链表，循环链别的实现，推荐你看这篇文章[链表的JS实现](https://www.jianshu.com/p/d20169988bc4)\n\n\n# 3.栈\n\n作为一名已经开始接触算法与数据结构的工程师，“栈”这个词一定并不陌生，你应该也很清楚的知道其特点：**“先进者后出，后进者先出”** 譬如一摞碟子，就非常符合栈的特点：\n\n![](https://www.xr1228.com//post-images/1590937459099.jpg)\n\n栈是一种操作受限的线性表，它只允许在一端插入和删除数据。那为什么非要用栈呢？数组和链表它不香吗？\n事实上，就功能性而言数组和链表确实可以替代栈，但是**特定的数据结构是对特定应用场景的抽象**，数组和链表暴露了太多接口，操作上太灵活就会导致使用不可控，更容易出错。\n\n所以。\n**当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。\n**\n\n栈可以使用链表实现（链式栈）也可以采用数组实现（顺序栈）。\n\n### 顺序栈的实现\n\n```js\nclass Stack{\n    constructor(){\n        this.dataStore = [];\n        this.top = 0;\n    }\n    //出栈\n    pop(){\n        return this.dataStore[--this.top];\n    }\n    //入栈\n    push(element){\n        this.dataStore[this.top++] = element;\n    }\n    //查看栈顶元素\n    peek(){\n        if(this.top>0){\n            return this.dataStore[this.top-1];\n        }else{\n            return 'Empty';\n        }\n    }\n    //栈内元素\n    length(){\n        return this.top;\n    }\n}\n```\n\n```js\nvar demo = new Stack();\ndemo.push('first');\ndemo.push('second');\nconsole.log(demo.peek()); // second\ndemo.length() // 2\ndemo.pop(); // second\nconsole.log(demo.peek()); // first\n```\n\n链式栈的实现在这里不做详细说明，毕竟我们以解决问题为首要目的，日常使用中能够实现栈这种数据结构即可。栈的操作都是简单的赋值操作，所以时间复杂度都为O(1)\n\n### 栈的作用：\n那么栈这种数据结构有什么作用？为什么要做这么多的限制？\n\n- 函数调用栈\n   操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。\n   举个例子就很好理解了：\n```c\n\nint main() {\n   int a = 1; \n   int ret = 0;\n   int res = 0;\n   ret = add(3, 5);\n   res = a + ret;\n   printf(\"%d\", res);\n   reuturn 0;\n}\n\nint add(int x, int y) {\n   int sum = 0;\n   sum = x + y;\n   return sum;\n}\n```\n\n![](https://www.xr1228.com//post-images/1590942295900.jpg)\n\n- 栈处理表达式求值：\n\n为了方便解释，我将算术表达式简化为只包含加减乘除四则运算，比如：34+13✖9+44-12/3。对于这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事儿。如果换作你，让你来实现这样一个表达式求值的功能，你会怎么做呢？实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。我将 3+5✖8-6 这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程。\n\n![](https://www.xr1228.com//post-images/1590942557874.jpg)\n\n- 栈处理括号匹配\n除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。\n\n\n# 4.队列\n\n队列与栈非常类似,也只支持\"入\"与\"出\" .排队买票就是一个队列,先来的人先买,后来的人后买.\n\n![](https://www.xr1228.com//post-images/1590973422823.jpg)\n\n它在许多底层系统,中间件中有着广泛的应用.队列可以通过基于数组或链表的方式实现.我们这里演示基于数组的实现方式.\n\n```js\nclass Queue{\n    constractor(){\n        \n    }\n}\n```\n",
      "data": {
        "title": "【实践数据结构与算法】一、几种最基础的数据结构",
        "date": "2020-05-28 17:33:35",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/jiegou.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jiegou"
    },
    {
      "content": "凌晨时分，你写出一段代码，实现了某个算法，优雅如诗。默默在心底说一声：“NB！” 但你知道这注定无人知晓，因为身边早已寂静无声。\n但你写的代码是否真的NB？复杂度或许能够解决这个问题。\n\n<!-- more -->\n\n> 学习数据结构与算法，就注定无法绕开复杂度分析。\n\n## 1.为什么需要复杂度分析？\n试想，如果不采用复杂度分析，判断一个算法的好最好的方法就是直接将代码跑一遍。但直接运行代码来观察其效率有几个致命的缺点：\n1. 事后分析：你不得不把代码写出来才能评估一种算法是否高效\n2. 依赖测试环境：测试电脑的配置直接决定了算法的运行时间。\n3. 测试结果受到数据规模的影响：不同的算法在不同数据规模下的表现不一致。\n   \n但是评价算法的执行效率本身就是一种“刚需”，毕竟算法就是为了提升效率，我们向领导汇报的时候，总得需要一个指标来告诉领导我们的价值吧？\n\n所以说，我们需要一种评价方法，能够在事前就大概估算出一个算法的执行效率 。 —— 复杂度\n\n## 2.大O复杂度表示法\n\n如何把算法的效率直观的表达出来呢？我们来看一段代码\n\n```js\nfunction cal(n){\n    let sum = 0;\n    let i = 1;\n    for(; i<=n ; ++i ){\n        sum = sum + i\n    }\n    return sum;\n}\n```\n**复杂度计算是一种粗略的估算，那么我们也就粗略的认为对于计算机来说，执行每一行代码的时间是相同的。**  \n我们假设计算机执行一行代码需要的时间为：T。  那么\n- 第二行 let sum = 0；需要消耗 T*1；\n- 第三行 let i = 1； 需要消耗 T*1；\n- for循环将执行N次，每次执行会做执行一次  sum=sum+1 与 ++i ，需要消耗 N * 2T；\n- 第七行 return sum；仅仅是一个返回值，并不涉及到数据运算与赋值，不算消耗。\n根据以上计算，该算法执行的时间消耗是  **（2N+2）*T**\n\n按照这个思路，下面这段代码\n\n```js\nfunction cal(int n){\n    let sum = 0;\n    let i = 1;\n    for(; i<=n;++i){\n        j = 1;\n        for(; j <= n ; ++j){\n            sum = sum + i * j ;\n        }\n    }\n    return sum;\n}\n```\n为了便于理解，我还是罗嗦的依次分析：\n- 第二行，第三行 各消耗一个 T ；\n- 外层for循环中 j = 1 与 ++i 总计执行了 2*N次；\n- 内层for循环中 sum=sum + i*j 与 ++j 总计执行了  $2N^2$次\n- 总计该算法执行消耗了 T(n) =  $2N^2+2N+2(T)$\n\n你有没有发现，无论如何计算，T(n) 与 n有一个比例关系。代码执行次数越多，T(n)与n的比例越大。\n我们把这个规律成一个公式\n\n> $T(n) = O(f(n))$\n\n- T(n) 表示代码执行的总时间\n- n 表示数据规模的大小\n- f(n) 表示代码执行次数的总和\n- 公式中O表示代码执行时间T(n)与执行次数f(n) 成正比。\n\n第一个例子就可以写作T(n) = O(2n+2)，第二个例子可以写作 T(n) = O($2n^2$+2n+3)。这就是**大O时间复杂度表示法**\n\n大O的时间复杂度并不是表示具体代码需要执行多久，而是反映了**代码执行时间随着数据规模增大的变化趋势**。所以，也叫**作渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。\n\n在时间复杂度计算中，通常我们要把低阶、常量、系数省略掉，毕竟当n很大时，这些因素的影响会变得很小。更重要的是我们毕竟是一种粗略的计算。 \n\n所以，第一个例子可以写作 T(n) = O(n) 第二个例子写作  T(n) = O($n^2$)\n\n确实，就是这么简单。 \n![简单.png](https://www.xr1228.com//post-images/1590597451637.png)\n\n\n## 3.时间复杂度分析\n\n复杂度的定义我们知道了，具体分析一段代码的时间复杂度时有以下几个技巧。\n\n1. 最多法则:  只关注循环次数最多的代码\n2. 加法法则：总复杂度等于量级最大的代码的复杂度\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n篇幅有限，这里就不罗列代码举例了。多思考，多练习即可。这种入门知识想必难不倒阁下。\n\n>  我亦无他，惟手熟尔。 \n\n下面列举一些常用的复杂度量级，并一一分析。\n\n![](https://www.xr1228.com//post-images/1590598066901.jpg)\n\n#### 1. O(1)\nO(1)是常量级的时间复杂度表示方式，并不是说只有一行代码. 只要代码执行时间不随数据量增加变化而变化，即使它有成千上万行代码，其时间复杂度仍然是 O(1)\n```\nlet i =2 ;\nlet j =3 ;\nlet sum = i + j ;\n```\n\n#### 2. $O(logn)$,$O(n*logn)$\n\n对数阶时间复杂度很常见,但是也是最难的分析的一种. 我门通过一个例子来说明一下:\n\n```c\ni = 1 ;\nwhile(i <= n){\n    i = i * 2;\n}\n```\n\n根据我们之所说的**最多法则**,我们只看循环次数最多的部分.第三行代码: i = i *2; 只要我们知道这行**代码循环了多少次**,复杂度就分析出来了.\n从代码中可以看出,\n- 变量i的值从1开始取\n- 每循环一次就乘以2.当大于n时循环结束. \n那么到底循环了多少次呢? 我门不妨穷举一下 i在每次循环中的变化:\n\n$2^0 , 2^1 ,  2^2  ...  2^k ... 2^x$\n\n当 $2^x$ > n时循环结束,循环次数是 x . 根据高中数学知识,我们知道 x =$log_2 n$ .所以这段代码的时间复杂度是 $O(log_2n)$\n\n现在我们把这段代码稍微改一下\n```c\ni = 1 ;\nwhile(i <= n){\n    i = i * 3;  //这里做了修改\n}\n```\n根据我们之前的思路,不难算出它的时间复杂度是 $O(log_3n)$  .但实际计算过程中不论是以2为底还是以3位底亦或是以10为底,我们把对数阶复杂度都标记为 $O(logn)$\n\nwhy?  我们再拿出高中数学知识, 对数之间是可以相互转换的\n\n>  $log_3n = log_3 2*log_2n$   \n\n在打O标记复杂度方法中,系数是可以忽略的,所以我们就粗略的认为 $O(log_2n)=O(log_3n)$   这样在对数阶时间复杂度分析中,我们把对数的\"底\"这个概念忽略掉,统一表示为 O(logn)\n\n那么 O(nlogn) 就很容易理解了: 如果一个方法的时间复杂度是O(logn),我们把它循环n次,它的时间复杂度就是  O(nlogn) . Esay!\n\n> O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。\n\n\n#### 3.O(m+n),O(m*n)\n\n有的时候,一个算法的时间复杂度是由两个数据共同决定的,我们再举个例子\n\n```js\nfunction cal(m,n){\n    let sumA =0;\n    for(let i = 0;i<m;++i){\n        sumA = sumA + i;\n    }\n    let sumB =0;\n    for(let i = 0;i<n;++i){\n        sumB = sumB + i;\n    }\n    return sumA+sumB;\n}\n```\n\n不难看出,上面代码的时间复杂度是 O(m+n)  因为m和n的数据量大小我们都是不知道的,无法忽略,就不能参考加法原则了. 类似的还有 O(m*n).\n\n## 4.空间复杂度分析\n\n掌握了时间复杂度和大O表示法,空间复杂度的计算就显得\"A piece of cake\"(这是贫道初中最喜欢用的的一个句子)\n\n前文说到, 时间复杂度其实是 **算法执行时间与数据规模之间的增长关系.**\n类似的,空间复杂度就是**算法的存储空间与数据规模之间的增长关系**\n\n继续举个例子,毕竟,代码是工程师最擅长的语言:\n\n```js\nfunction print(n){\n    let arr = [];\n    let i = 0;\n    for(i;i<n;++i){\n        arr.push(i*i)\n    }\n    for(i=n-1;i>=0;--i){\n        console.log(arr[i]);\n    }\n}\n```\n\n和时间复杂度分析一样,:\n- 在第二行,我们申请了一个空间存储 arr,\n- 在第三行我们申请了一个空间存储变量i  \n除此之外所有的代码都没有占用跟多空间,所以整段代码的空间复杂度是O(n+1),省略常量阶,省略系数最后这段代码的控件复杂度是 O(n)\n\n我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。\n\n\n> 复杂度计算就是一把尺子,一把从时间和空间的角度共同丈量算法执行效率的尺子. 这把尺子或许很粗糙,但是其实很简单很有用.\n\n\n\n以上就是复杂度计算的基础内容了,本文是由王争的在线教程[<数据结构与算法之美>](!https://time.geekbang.org/column/intro/126)总结而来,如果想了解进阶的复杂度计算知识你可以学习这门课程或者在百度搜索:\n\n- 最好情况时间复杂度（best case time complexity）\n- 最坏情况时间复杂度（worst case time complexity）\n- 平均情况时间复杂度（average case time complexity）\n- 均摊时间复杂度（amortized time complexity）\n\n\n而作为一个专注于解决问题的工程师,我认为你掌握到现在这个程度就完全满足以后的开发需求了.\n\n![](https://www.xr1228.com//post-images/1590653100184.jpg)\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【实践数据结构与算法】衡量算法和数据结构的尺子：复杂度计算",
        "date": "2020-05-27 23:22:48",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/fuzadufenxi.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "凌晨时分，你写出一段代码，实现了某个算法，优雅如诗。默默在心底说一声：“NB！” 但你知道这注定无人知晓，因为身边早已寂静无声。\n但你写的代码是否真的NB？复杂度或许能够解决这个问题。",
      "fileName": "fuzadufenxi"
    },
    {
      "content": "> 发动机之于汽车,九阳真经之于张无忌,数据结构之于编程.\r\n\r\n本文并不是数据结构和算法的学习教程,而是面向解决问题来讨论数据结构与算法,是在实践过程中对数据结构与算法的高度总结.\r\n<!-- more -->\r\n\r\n## 什么是数据结构与算法\r\n\r\n> 数据结构是一组数据的存储结构. 算法是操作数据的一组方法. \r\n\r\n**算法与数据结构是相辅相成的,没有建立在数据结构上的算法,讨论数据结构也没有意义.**\r\n\r\n举个例子 : 工厂仓库需要存放成百上千个商品. 存放商品的方式就是数据结构, 而对于商品的查找,盘点,分类就属于算法.\r\n\r\n然而数据结构与算法的涉及面实在太广,俗话说\"一入算法深似海\",为了防止我或者你放弃,所以我们集中讨论实际工作与代码优化中会用到的20个算法与数据结构.\r\n\r\n## 本文集中讨论的20个数据结构与算法\r\n\r\n- 数据结构: 数组,链表,栈,队列,散列表,二叉树,堆,跳表,图,Trie树\r\n- 算法: 递归,排序,二分查找,搜索,哈希算法,贪心算法,贪心算法,分治算法,回溯算法,动态规划,字符串匹配算法\r\n\r\n\r\n## 我希望达到的目的\r\n\r\n作为一个以解决问题为主的工程师,我认为编程只是一种工具. 我希望能尽自己最大的能力,从实际出发,一起领略数据结构与代码之美.",
      "data": {
        "title": "【实践数据结构与算法】开篇词:数据与算法之美",
        "date": "2020-05-26 09:52:27",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/suanfazhimei.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "> 发动机之于汽车,九阳真经之于张无忌,数据结构之于编程.\r\n\r\n本文并不是数据结构和算法的学习教程,而是面向解决问题来讨论数据结构与算法,是在实践过程中对数据结构与算法的高度总结.\r",
      "fileName": "suanfazhimei"
    },
    {
      "content": "> 之所以要分上下两个部分,是因为我实在是担心你没有耐心一口气读完全文. 但闭包之于JS,就如同麻酱之于火锅. 那是灵魂\n<!-- more -->\n\n## 1.闭包的概念\n\n> 闭包就是函数能够记住它的词法作用域,及时它在其他地方执行时.\n\n负责任的说:如果你细细度了本文上篇的内容,这句话就能让你豁然开朗.我们举个例子\n\n```js\nfunction foo() {\n\tvar a = 2;\n\tfunction bar() {\n\t\tconsole.log( a ); // 2\n\t}\n\tbar(); //注意这句!!!\n}\n\nfoo();\n```\n从定义上来讲,因为bar()在foo()中调用了,且bar访问了foo()中的变量,我们认为**bar()闭住了foo()的作用域**,它形成了一个闭包.\n**但是!**\n这不是我们要讨论的闭包.上面的代码虽然形成了闭包,但是bar()并没有供外部调用.\n\n我们来看一段真正的闭包:\n```js\nfunction foo() {\n\tvar a = 2;\n\tfunction bar() {\n\t\tconsole.log( a );\n\t}\n\treturn bar;\n}\nvar baz = foo();\nbaz(); // 2 -- 哇噢，看到闭包了\n\n```\n我们来解释一下: \n1. 函数bar()对于foo()的函数作用域拥有访问权. \n2. 我们将bar()这个函数像值一样传递(return)  即 return bar;\n3. 执行bar = foo()时我们就获得了返回值 bar();\n4. 当我们调用baz的时候,我们本质上就调用了 bar();\n   \n这下聪明的你隐约间有了一种说不清道不明的感. 之所以说不清楚,因为你不知道这么做有什么用. \n\n先说结论: \n> 闭包可以避免垃圾回收机制\n\n根据JS垃圾回收机制,一般来说foo()执行后,其内部作用域都将消失,被垃圾回收机制释放掉. 但是当闭包出现后,垃圾回收机制就被阻止了! \n在闭包出现后,foo()内部作用域仍然存在,因为函数bar()在使用它. 通过闭包,我们依旧可以继续访问在程序编写时定义的词法作用域.\n\n所以说,我们回头再看看闭包的定义. \n\n> 闭包就是函数能够记住它的词法作用域,及时它在其他地方执行时.\n\n形成闭包只需要  在函数A内部嵌套一个函数B,只要函数B能够访问函数A的内容且被执行,就形成了闭包.\n\n## 2.闭包的不同形式\n\n除了通过值传递,闭包在其他位置调用也可以形成闭包.\n\n```js\n\nfunction foo() {\n\tvar a = 2;\n\n\tfunction baz() {\n\t\tconsole.log( a ); // 2\n\t}\n\n\tbar( baz );\n}\n\nfunction bar(fn) {\n\tfn(); // 看妈妈，我看到闭包了！\n}\n\nfoo(); //2\n```\n\n内部函数bar()被传递给了bar,而bar是定义在全局作用域中的函数. 这样就形成了一个闭包,且在外部bar()作用域中被调用了.\n\n这样的函数传递也可以是间接的.\n\n```js\nvar fn;\n\nfunction foo() {\n\tvar a = 2;\n\n\tfunction baz() {\n\t\tconsole.log( a );\n\t}\n\n\tfn = baz; // 将`baz`赋值给一个全局变量\n}\n\nfunction bar() {\n\tfn(); // 看妈妈，我看到闭包了！\n}\n\nfoo();\n\nbar(); // 2\n```\n\n无论我们使用什么方法,只要将内部函数传送到其词法作用域外,函数都将维护一个最开始被声明时候的作用域的引用. 无论我们什么时候执行它,闭包都会运行.且运行的变量是**最开始声明时候的作用域**\n\n## 3.无处不在的闭包\n\n其实闭包,已经被应用在你的项目中且无处不在了. \n\n```js\nfunction wait(message) {\n\n\tsetTimeout( function timer(){\n\t\tconsole.log( message );\n\t}, 1000 );\n\n}\n\nwait( \"Hello, closure!\" );\n```\n虽然通常我们不这样写,但这段代码能够很好的说明闭包的运行规则,\n\n1. 首先setTimeout是一个JS自有的全局函数.\n2. 我们将timer()传递给setTimeout(..), timer()包含着对于wait词法作用域的引用\n3. 当我们执行wait()时,虽然1000ms后才执行timer(),但是它仍然记忆着message的内容\n\n**这就是闭包** 就是这么简单\n\n我们再举一个循环的例子,循环被认为是解释闭包原理最好的例子.\n```js\nfor (var i=1; i<=5; i++) {\n\tsetTimeout( function timer(){\n\t\tconsole.log( i );\n\t}, i*1000 );\n}\n```\n答案是: 6 (循环五次)   我们本来的期望是1,2,3,4,5 但实际情况却事与愿违. \n就定时器而言,定时器都是在循环执行结束后才执行的,此时timer()所执行的值是当前全局作用域中的 i\n如何解决这样的问题? \n或许我们可以通过立即执行函数在每次一生成setTimeout时给其一个单独的i\n```js\nfor (var i=1; i<=5; i++) {\n\t(function(){\n\t\tsetTimeout( function timer(){\n\t\t\tconsole.log( i );\n\t\t}, i*1000 );\n\t})();\n}\n```\n\n但这样不行,因为虽然我们在立即函数执行过程中新建了许多空的作用域,**但这些作用域中并没有内容,它仍然会到全局作用域中查找变量 i . **\n\n我们可以在被闭包的作用域加入内容\n\n```js\nfor (var i=1; i<=5; i++) {\n\t(function(){\n\t\tvar j = i;\n\t\tsetTimeout( function timer(){\n\t\t\tconsole.log( j );\n\t\t}, j*1000 );\n\t})();\n}\n```\n或者是这种形式\n```js\nfor (var i=1; i<=5; i++) {\n\t(function(j){\n\t\tsetTimeout( function timer(){\n\t\t\tconsole.log( j );\n\t\t}, j*1000 );\n\t})( i );\n}\n```\n但当我们采用块级作用域,代码会变得更加NB\n\n```js\nfor (let i=1; i<=5; i++) {\n\tsetTimeout( function timer(){\n\t\tconsole.log( i );\n\t}, i*1000 );\n}\n```\n在用于 for 循环头部的 let 声明被定义了一种**特殊行为**。这种行为说，这个变量将不是只为循环声明一次，而是为每次迭代声明一次。并且，它将在每次后续的迭代中被上一次迭代末尾的值初始化。\n简而言之,采用块级作用域为每一次循环附上单独的值.\n\n\n## 4.闭包的用途(转自[阮一峰 学习Javascript闭包（Closure）](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html))\n\n闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n怎么来理解这句话呢？请看下面的代码。\n\n```js\n　　function f1(){\n\n　　　　var n=999;\n\n　　　　nAdd=function(){n+=1}\n\n　　　　function f2(){\n　　　　　　alert(n);\n　　　　}\n\n　　　　return f2;\n\n　　}\n\n　　var result=f1();\n\n　　result(); // 999\n\n　　nAdd();\n\n　　result(); // 1000\n```\n在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n\n为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n\n\n这段代码中另一个值得注意的地方，就是\"nAdd=function(){n+=1}\"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。\n\n## 5.使用闭包的注意点\n\n1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n\n2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【前端拾遗】JS核心知识点——关于闭包的一切(下)",
        "date": "2020-05-25 15:22:23",
        "tags": [
          "值得一读",
          "前端拾遗"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/bibaoxia.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "> 之所以要分上下两个部分,是因为我实在是担心你没有耐心一口气读完全文. 但闭包之于JS,就如同麻酱之于火锅. 那是灵魂",
      "fileName": "bibaoxia"
    },
    {
      "content": "闭包作为前段封装函数，私有化变量的常用手段，几乎是出现在所有面试问题当中。虽然说闭包已经在我们的程序中无处不在，但作为一个日常面向用户写业务代码的程序员，我们总是对闭包一知半解，模棱两可，希望可以通过这篇文章详解关于闭包的一切。\n\n\n<!-- more -->\n\n> 对于那些有一点JavaScript使用经验但从未真正理解闭包概念的人来说，理解闭包甚至可以看作是某种意义上的重生。\n\n## 1.闭包的前置知识：作用域与词法作用域\n\n### 什么是作用域？\n\n作用域并不是JS独有的概念，对于任何编程语言来说，只要它能够定义变量、获取变量中的内容，就需要用到作用域的概念。\n\n> 作用域就是一套规则,它明确**程序在哪里以及如何查找变量(标识符).**\n\n通俗的说,作用域就是告诉你的程序,你去哪儿找变量. 我们来看一段代码.\n\n```js\n//代码片段1\nfunciton foo() {\n    var a = 'i am a';\n    console.log(a); \n}\nfoo(); //程序输出 i am a\n//代码片段2\nvar b = \"i am b\";\nfunction foo2(){\n    console.log(b);\n}\nfoo2(); //代码输出 i am b\n```\n第一段代码查找变量,在**函数内部**找到了a,程序就停止查找并且输出a;\n第二段代码先在函数内部查找b,没有找到就到**全局**中查找,找到了b,停止查找并且输出b;\n用程序员的黑话来说, 第一段代码在**函数作用域**中找到变量,第二段代码在**全局作用域**中找到变量\n\n聪明如你一定发现,第二段代码先从函数内部进行查找变量,没有找到后在外部查找变量. 仿佛程序沿着一条由内向外的链条来查找变量. 这个链条我们称之为:**作用域链**\n\n### 作用域的嵌套\n\n在ES6之前(ES6为了明确作用域增加了let,const关键字),只有函数作用域和全局作用域.全局作用域包含函数作用域,而函数作用域又可以嵌套函数作用域.\n\n![](https://www.xr1228.com//post-images/1590372683410.png)\n\n用代码表示:\n\n![](https://www.xr1228.com//post-images/1590372697520.png)\n\n### 作用域的工作规则\n\n尽管JS是一种脚本语言(边编译边运行),但JS是有预编译阶段的. 这里我们不讨论复杂且精妙的JS编译过程,直接放出结论: \n\n JS在代码运行前先从上到下进行编译\n - 变量声明 : 遇到var声明的变量时,如果当前作用域已经存在该变量则忽略,如果不存在则在当前作用域中声明这个变量.\n - 变量取值 : 在当前作用域查找变量.如果没有找到则到父级查找,以此类推,直到全局作用域.如果还没有找到就报错: ReferenceError: XX is not defiend;\n - 变量赋值 : 同样在当前作用域中查找,如果没有找到则到父级查找,以此类推,直到全局作用域如果还没有找到**,在非严格模式下则创建一个全局变量.**\n\n### 词法作用域\n\n作用域是一种规则,而这种规则有两种运行模式: \n- 词法作用域\n- 动态作用域\n\n所谓词法作用域,就是在程序员编写程序的时候,根据变量定义的位置就确定了作用域.和大多数编程语言一样,JS也采用了词法作用域.\n\n> 相对的,动态作用域是不在乎变量定义的位置,仅关注变量时在哪里调用的.。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。\n\n我们用一段代码来说明一下这两种模式的区别.\n\n```js\nvar a = 2;\nfunction foo() {\n  console.log(a); // 会输出2还是3？\n}\nfunction bar() {\n  var a = 3;\n  foo();\n}\n\nbar();\n```\n\n- 词法作用域下:  foo() 在申明阶段,引用是全局作用域,所以该函数输出为 2\n- 动态作用域下(假设js是动态作用域): foo() 输出应该是 3\n\n总而言之,词法作用域实在写代码或者定义时候明确的,关注函数在哪里申明.而动态作用域是在运行时确定的,关注函数在哪里调用.\n\n 这也对于词法作用域我们总是感觉很别扭,因为人类的大脑其实是习惯了动态作用域来思考问题.\n我们用一段伪代码来还原大脑的\"作用域\"\n\n```js\nvar 小明的学历 = \"文盲\";\n\nfunction 学历( ){\n    console.log(小明的学历);\n}\n\nfunction 上学(){\n    var 小明的学历 = \"小学\";\n    学历();\n}\n上学();\n```\n\n我们人为已经上过学的小明肯定是小学学历,但是在词法作用域看来,小明仍然是一个文盲.\n\n\n## 2. 为什么要有作用域?\n\n是的,我们已经知道作用域的运行规则,但是为什么要整这么多作用域呢? 大家都全局调用不好吗? 小朋友你是否有很多问号?\n\n![](https://www.xr1228.com//post-images/1590377477309.gif)\n\n\n这个问题其实不难解答.我们先写出结论:\n\n1. 变量私有化\n2. 避免命名冲突\n\n### 变量私有化\n```js\nfunction foo(a) {\n\tvar b = 2;\n\t// 一些代码\n\tfunction bar() {\n\t\t// ...\n\t}\n\t// 更多代码\n\tvar c = 3;\n}\n\nbar();  //报错\n\nconsole.log(a,b,c); //报错\n```\n很明显,程序报错了. 因为 bar(),a,b,c 都是 foo() 函数内部的变量,这些变量在同一个函数作用域内(foo的函数作用域) 是可以互相访问的,但是外部函数想要调用他们却不行. 这种设计思想的好处显而易见 —— 变量可以根据需要来接受不同类型的值. 我们不但避免变量名称的重复,同时也能将私有化的变量在函数中隐藏起来,不至于过多的暴露到外部. (\"最低权限\"设计原则)\n\n<你不懂的JS> 提到了一个很好的例子:\n\n```js\nfunction doSomething(a) {\n\tb = a + doSomethingElse( a * 2 );\n\n\tconsole.log( b * 3 );\n}\n\nfunction doSomethingElse(a) {\n\treturn a - 1;\n}\n\nvar b;\n\ndoSomething( 2 ); // 15\n```\n\n这个代码段中，变量 b 和函数 doSomethingElse(..) 很可能是 doSomething(..) 的“私有”细节。允许外围的作用域“访问” b 和 doSomethingElse(..) 不仅没必要而且可能是“危险的”.换一种写法获取更加恰当:\n```js\nfunction doSomething(a) {\n\tfunction doSomethingElse(a) {\n\t\treturn a - 1;\n\t}\n\n\tvar b;\n\n\tb = a + doSomethingElse( a * 2 );\n\n\tconsole.log( b * 3 );\n}\n\ndoSomething( 2 ); // 15\n```\n现在，b 和 doSomethingElse(..) 对任何外界影响都是不可访问的，而是仅仅由 doSomething(..) 控制。\n\n### 避免变量冲突\n\n将变量和函数隐藏在一个作用域内部就很容易避免同名变量之间发生冲突.(不要在浏览器中尝试这段代码,别问我怎么知道的.)\n```js\nfunction foo() {\n\tfunction bar(a) {\n\t\ti = 3; // 在外围的for循环的作用域中改变`i`\n\t\tconsole.log( a + i );\n\t}\n\n\tfor (var i=0; i<10; i++) {\n\t\tbar( i * 2 ); // 噢，无限循环！\n\t}\n}\nfoo();\n```\nbar(..) 内部的赋值 i = 3 地覆盖了在 foo(..) 的for循环中声明的 i。这是因为 bar作为内部函数可以访问外部作用域,i=3改变了外部函数的i,导致循环无法停止.\n将 i =3; 改为 var i = 3; 就可以有效解决这个问题. \n\n试想一下,你的项目引用了很多外部的库,而这些库没有隐藏内部/私有函数变量,那么就很容易出现类似的冲突.\n\n## 3.函数作用域与块作用域\n\n说实在的,作为一个以解决问题为首要目的的程序员,我已经在努力把这个事情说的简单清晰. 如果你感觉很啰嗦,那就当做\"听妈妈的话\"吧..... 相信当你仔细读完之后一定会发现JS的乐趣. \n\n你已经知道,只要声明一个函数把一段代码包裹起来,就能够建立一个作用域,将内部的变量或者函数声明\"隐藏\"起来.\n\n```js\nvar a = 2;\nfunction foo() { \n\tvar a = 3;\n\tconsole.log( a ); // 3\n} \nfoo(); \nconsole.log( a ); // 2\n```\n但这样并不理想. 你看,我们为了将 a 变量隔离, 不但需要声明一个函数foo(); 还要后面引用它才能达到我们的目的. 事实上声明foo()其实也是一种命名污染. \n\n> 如果这个函数不需要命名(或者命名了也不会对外部作用域产生影响)并且能自动运行就好了. ^_^\n\n的确,JavaScript提供了解决方法:  立即执行函数\n\n```js\nvar a = 2;\n\n(function foo(){ // <-- 插入这个\n\tvar a = 3;\n\tconsole.log( a ); // 3\n})(); // <-- 和这个\n\nconsole.log( a ); // 2\n```\n\n**当function..通过(function..)的形式包裹起来后,这个函数不再是一种函数声明,而是变成了一个函数表达式.**\n\n> 简而言之,通过()包裹起来后,原来的函数foo从 \"定义foo()\"变成了 \"执行foo()里的代码\"\n\n这个时候,即使我们在立即执行函数中命名了函数名称foo, 在全局作用域中也无法调用 foo(). 它不再没有必要的污染外部作用域了.\n\n### 匿名函数\n\n当然你也可以不对函数进行命名\n```js\nvar a = 2;\n(function(){ \n\tvar a = 3;\n\tconsole.log( a ); // 3\n})(); \nconsole.log( a ); // 2\n```\n但是它有几个缺点:\n1. 在栈轨迹上匿名函数没有有用的名称可以表示，这可能会使得调试更加困难。\n2. 没有名称的情况下，如果这个函数需要为了递归等目的引用它自己，那么就需要很不幸地使用 被废弃的arguments.callee 引用。另一个需要自引用的例子是，当一个事件处理器函数在被触发后想要把自己解除绑定。\n3. 名称经常对提供更易读/易懂的代码很有帮助。一个描述性的名称可以帮助代码自解释。\n\n所以还是建议为自己的立即执行函数进行命名.\n\n\n### 块级作用域\n\n虽然说函数作用域是最常见的作用域单位,但在ES6之前的JavaScript在代码书写方面并不符合程序员的思维习惯. ES6之后引入的let和const可以帮助我们写出更好的,更简洁且易于维护的代码.\n\n```js\nfor (var i=0; i<10; i++) {\n\tconsole.log( i );\n}\n```\n譬如上面这段非常常见代码,我们的本意是希望定义一个 i在循环内部使用,但实际上却将i划入了外部作用域. \n再譬如下面这段代码: 我们的本意是将bar作为if中使用的变量,但它依旧暴露在全局作用域中了.\n```js\nvar foo = true;\n\nif (foo) {\n\tvar bar = foo * 2;\n\tbar = something( bar );\n\tconsole.log( bar );\n}\n```\n\n那该如何是好呢? JavaScript并将代码块作为作用域的能力呀. \n\n![](https://www.xr1228.com//post-images/1590390075720.jpg)\n\n但是ES6已经很好的解决了这个问题:\n\n### let与const\n\nlet和const 关键字将变量声明附着在它所在的任何块（通常是一个 { .. }）的作用域中。换句话说，let 为它的变量声明隐含地劫持了任意块作用域。我们可以通过简单地引入一个 { .. } 来为 let 创建一个任意的可以绑定的块儿。在这个例子中，我们在 if 语句内部制造了一个明确的块儿，在以后的重构中将整个块儿四处移动可能会更容易，而且不会影响外围的 if 语句的位置和语义。\n\n```js\nvar foo = true;\n\nif (foo) {\n\tlet bar = foo * 2;\n\tbar = something( bar );\n\tconsole.log( bar );\n}\n\nconsole.log( bar ); // ReferenceError bar is not defined\n```\n\n> 注:除了let与const之外,with结构,try,catch也是块级作用域.这里不做详细讨论\n\n\n\n### 垃圾回收机制\n块儿作用域的另一个有用之处是关于闭包和释放内存的垃圾回收。我们将简单地在这里举一个例子.\n获取这个例子稍稍有一些复杂,但既然你已经读到这里了,那说明你肯定能看懂.\n\n```js\nfunction process(data) {\n\t// ****\n}\n\nvar someReallyBigData = { .. };  //一个巨大的对象\n\nprocess( someReallyBigData );\n\nvar btn = document.getElementById( \"my_button\" );\n\nbtn.addEventListener( \"click\", function click(evt){\n\tconsole.log(\"button clicked\");\n}, /*capturingPhase=*/false );\n```\n\n\n当我们执行回调函数 click时,不需要someReallyBigData这个变量. 这意味着从理论来说,在process(..)执行后我们可以把someReallyBigData回收掉来释放内存.\n\n但是JS引擎通常会将这个someReallyBigData继续保存一段时间,因为click在整个作用域上拥有一个闭包,导致JS引擎不敢冒然将someReallyBigData回收掉.\n\n但是块级作用域可以明确的告诉JS引擎可以执行垃圾回收了.\n\n```js\nfunction process(data) {\n\t// 做些有趣的事\n}\n\n// 运行过后，任何定义在这个块中的东西都可以消失了\n{\n\tlet someReallyBigData = { .. };\n\n\tprocess( someReallyBigData );\n}\n\nvar btn = document.getElementById( \"my_button\" );\n\nbtn.addEventListener( \"click\", function click(evt){\n\tconsole.log(\"button clicked\");\n}, /*capturingPhase=*/false );\n```\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【前端拾遗】JS核心知识点——关于闭包的一切(上)",
        "date": "2020-05-25 00:44:59",
        "tags": [
          "前端拾遗",
          "值得一读"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/JSPoint.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "闭包作为前段封装函数，私有化变量的常用手段，几乎是出现在所有面试问题当中。虽然说闭包已经在我们的程序中无处不在，但作为一个日常面向用户写业务代码的程序员，我们总是对闭包一知半解，模棱两可，希望可以通过这篇文章详解关于闭包的一切。",
      "fileName": "JSPoint"
    },
    {
      "content": "> 一切软件，终将用JS再实现一遍。\n<!-- more -->\n几年前读到上面这句话时，我是满头黑人问号。一个脚本语言，名字还蹭JAVA的热度，怎敢夸口说什么千秋万代一统江湖。你把我C#放在眼里了嘛？\n![](https://www.xr1228.com//post-images/1590282695955.png)\n但现在想来，这句话其实反映了这十年里前端飞速发展的趋势。跨平台开发 Flutter、Electron、React Native，前端开发框架 Vue、React、Angular，前端工程化工具 Webpackage、Glup...  时至今日，作为一个全栈工程师，JS我的编辑器里占据了越来越多的比例。\n\n似乎，开篇的那一句话将在不远的将来成为现实。\n\n>关于JS的历史的内容转自简书-火锅伯南克\n作者：火锅伯南克\n链接：https://www.jianshu.com/p/33c1d8505975\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### 一、Nombas 和 ScriptEase\n大概在 1992 年，一家称作 Nombas 的公司开发了一种叫做 C 减减（C-minus-minus，简称 Cmm）的嵌入式脚本语言。Cmm 背后的理念很简单：一个足够强大可以替代宏操作（macro）的脚本语言，同时保持与 C （和 C ++）足够的相似性，以便开发人员能很快学会。这个脚本语言捆绑在一个叫做 CEnvi 的共享软件中，它首次向开发人员展示了这种语言的威力。\nNombas 最终把 Cmm 的名字改成了 ScriptEase，原因是后面的部分（mm）听起来过于消极，同时字母 C “令人害怕”。\n\n### 二、Mosaic\n1992 年浏览器中大部分是单纯的 HTML 查看器，用户还需要依靠外部辅助应用程序来查看图片等富媒体内容。真正让大家眼前一亮的产品是 Mosaic，第一个可以显示图片的浏览器。这是美国国家超级电脑应用中心（NCSA）在 1993 年开发的一款适用于多平台的网页浏览器，Mosaic 是第一个被人普遍接受的浏览器，它让许多人了解了Internet 。它的技术随后被授权给了多家公司，于是，商业公司们也可以基于其上开发新产品了。\n在这些商业公司里，最值得注意的一家叫**网景**。还有一家，叫**微软**。\n\n![](https://www.xr1228.com//post-images/1590287034322.jpg)\n\n### 三、Netscape 和 JavaScript（LiveScript）\n\n1994年Mosaic研发的核心成员马克·安德森（Marc Andreessen）和几何图形发生器的发明人吉姆·克拉克（Jim.H.Clark）共同创立了Mosaic Communication Corporation。同年11月为了避免与NCSA的法律纠葛，公司更名为Netscape Communication Corporation即网景公司，并一直沿用。\n\n二人试图打破Mosaic的垄断并取得业界的领导地位。所以研发了一款新浏览器，名为 Netscape Navigator，即“导航者”。对内其1.0版本的研发代号则为Mozilla！网景公司员工也常将其称作Moz或Mozzie。\n\n![](https://www.xr1228.com//post-images/1590287131552.jpg)\n\n**当 Netscape Navigator 崭露头角时，Nombas 开发了一个可以嵌入网页中的 CEnvi 的版本。这些早期的试验被称为 Espresso Page（浓咖啡般的页面），它们代表了第一个在万维网上使用的客户端语言。而 Nombas 丝毫没有料到它的理念将会成为万维网的一块重要基石。**\n\n>  JavaScript的雏形出现了。注意，是Nombas。\n\n随着网上冲浪越来越流行，对于开发客户端脚本的需求也逐渐增大。此时，大部分因特网用户还仅仅通过 28.8 kbit/s 的调制解调器连接到网络，即便这时网页已经不断地变得更大和更复杂。而更加加剧用户痛苦的是，仅仅为了简单的表单有效性验证，就要与服务器进行多次地往返交互。设想一下，用户填完一个表单，点击提交按钮，等待了 30 秒的处理后，看到的却是一条告诉你忘记填写一个必要的字段。\n\n那时正处于技术革新最前沿的 Netscape，开始认真考虑开发一种客户端脚本语言来解决简单的处理问题。\n\n**当时工作于 Netscape 的 Brendan Eich (布兰登·艾奇)，开始着手为即将在 1995 年发行的 Netscape Navigator 2.0 开发一个称之为 LiveScript 的脚本语言，当时的目的是在浏览器和服务器（本来要叫它 LiveWire）端使用它。Netscape 与 Sun 共同完成 LiveScript 实现。**\n\n![](https://www.xr1228.com//post-images/1590287388078.jpg)\n\n>布兰登·艾奇（生于1961年7月4日），美国技术专家和JavaScript 编程语言的创作者。他共同创办了Mozilla的项目的Mozilla基金会和Mozilla公司，并担任Mozilla公司的首席技术官，并简要的首席执行官。他是Brave Software的首席执行官。\n他于1995年4月开始在Netscape Communications Corporation工作.Eich最初加入了打算将Scheme “放入浏览器”，但他的Netscape上司坚持认为该语言的语法要类似于Java,因为网景公司的整个管理层，都是Java语言的信徒，而且网景公司以与Sun公司结成联盟，当时的Sun已经把Java成功地推向了市场。\n但是，布兰登·艾奇对Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。\n由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。如果Brendan Eich预见到，未来这种语言会成为互联网第一大语言，全世界有几百万学习者，他会不会多花一点时间呢?\n总的来说，他的设计思路是这样的：\n1.借鉴C语言的基本语法;\n2.借鉴Java语言的数据类型和内存管理;\n3.借鉴Scheme语言，将函数提升到\"第一等公民\"(first class)的地位;\n4.借鉴Self语言，使用基于原型(prototype)的继承机制。\n如果不是公司的决策，Brendan Eich绝不可能把Java作为Javascript设计的原型。作为设计者，他一点也不喜欢自己的这个作品：\n\"与其说我爱Javascript，不如说我恨它。它是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：'它的优秀之处并非原创，它的原创之处并不优秀。' (the part that is good is not original, and the part that is original is not good.)\"\n\n**就在 Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript，目的是为了利用 Java 这个因特网时髦词汇。Netscape 的赌注最终得到回报，JavaScript 从此变成了因特网的必备组件，网景也得到了物质回报。**\n1995年8月9日，公司首次公开募股获得巨大成功。原本股票价值，为每股14美元，但因这个临时决定，股价倍增至每股28美元。第一天收市，股价升至每股75美元，几乎是当时创记录的“首日获利”。1995年，该公司的收入每季上升一倍。\n\n### 四、微软 和 JScript\n一直到 1995 年中，市场上的网页浏览器标准都以 Netscape 主导，没公司相争，也没公司想争。\n随着网景的发展，它已多次尝试创做一种能够让用户通过浏览器操作的网络应用系统。这引起微软注意，担心网景可能威胁到微软的操作系统和应用程序市场。\n\n>这个就类似于微信客户端是苹果手机的一款应用，但是微信自己还搞了一个内置应用——小程序，这会直接影响苹果商店的应用使用问题，苹果当然会很警惕，只不过在这次较量中微信的头比苹果的硬而已。\n\n微软是第一个破局者。微软作为IT界老大，看到JavaScript 1.0 如此成功必然心里不舒服，于是在1995年买下Mosaic的授权，在获取 Mosaic 的授权后，微软迅速推出了 Internet Explorer 1.0，并于 1995 年 8 月起通过“Windows 95 Plus ! ”搭配出售。\n\n但是我们要清楚一点，微软最初的商业侧重点并不是互联网，而是PC 操作系统这块市场，到底是谁给了微软这么大的决心，要和几乎已经在浏览器市场坐稳的网景公司“背水一战”？\n\n是比尔盖茨。\n\n1995 年 5 月 26 日，比尔盖茨向微软内部所有员工发送了一份名为“互联网潮汐”的备忘录。在备忘录里，盖茨明确表示，他打算集中公司所有的技术力量，all in 互联网。\n\n盖茨在这份备忘录里发出警示：“互联网用户聚集在一起，也许会创造出比 PC 更有价值的东西。目前我不认为我们的产品可以做到，不过，我们已经找到了一个出生在互联网上的对手，Netscape，它是我们必须要打败的。”\n\n>备忘录内容：\n我们可以对过去 20 年的愿景做个简洁的概括，我们看到计算机功能发生了指数级的改进，这使得优秀的软件变得越来越有价值。对此，我们的回应是，建立一个足以提供最佳软件产品的系统。\n我们相信，在未来 20 年，计算机将对工作、学习和游戏产生根本性的影响。而出色的软件产品对于实现这些进步至关重要。\n大多数用户没有预判到未来通信价格将大幅下降。当前的有线电话网络仍在使用旧技术。PC 刚刚开始创造出额外的需求，这将推动一股新的投资浪潮。扩张的互联网，新的应用程序和更优质的宽带网络，将在未来十年内为大多数企业和家庭带来低成本的通信。\n我认为，未来几年互联网的发展将在很长一段时间内决定整个行业的方向。现在我为互联网分配了最高级别的重要性。我想明确指出，我们对互联网的关注是第一位的。\n自从 IBM 在 1981 年推出 PC 以来，互联网就开始有了巨大的转变。当前的电脑并不完美，个人的体验是相当差的。但是随着 PC 性能的增强，整个行业将找到新的机会。\n互联网的独特地位源于多种要素。TCP / IP 协议很重要，因为是它支持了分布式计算，并且让整个网络得到非常好的扩展性。也许未来地球上的每个人都能连接起来，服务器可能需要承载巨大的流量。\n关于超文本的预测，几十年就有了，而且部分预测已经实现。我相信，带扩展名的页面将成为定义信息呈现方式的新标准。HTML 的各种扩展，包括表格、安全交易等功能将在不久的将来得到广泛采用。也许还能有 3D 展示以支持 VR 购物和社交。\n互联网的另一个独特之处在于，它允许我们以商品的交易方式购买通信线路，通信线路的连接构成了“公共”网络，而“公共”网络的经济性反映了通信技术的进展情况。\n企业连接到互联网的成本取决于你进入互联网的“入口”的大小，而不是实际使用的程度。这意味着，额外使用的边际成本几乎为零。\n最重要的是，互联网可以成为一个发布内容的场所。它有足够的用户，它能从这些用户所贡献的内容的正反馈循环中获益，获得的用户越多，带来的内容就越多，反过来会带动更多用户的加入。\n当然，关于未来互联网的增长，我认为一个重要问题在于它的“临界质量”。现在我们看到，每种在线服务都可以为互联网增加额外价值。我们需要让它的整体价值不断凸显，以吸引用户克服成本考虑，真正地加入进来，让互联网达到爆发增长的“临界质量”。\n我们对这个“临界质量”没有足够明确的答案。但我们能做的是，使各项互联网服务非常，非常便宜——也许是免费的。\n我关注到两个现象：\n第一，在浏览互联网的过程中，我几乎找不到 Microsoft 能够支持的文件格式。我用了超过 10 个小时，但是没看到单个 Word 文档，AVI 文件，Windows .EXE 或我们能够支持的文件格式。不过我看到了大量的 Quicktime 文件。所有电影制片厂都使用它们来提供电影预告片。可那是属于苹果公司的。\n第二，Internet上另一种流行的文件格式是 PDF，甚至美国国税局也提供 PDF 格式的税表。目前来看 HTML 还有些局限，所以 PDF 是一种标准化的替代方案。Adobe 正在大力投资这项技术。\nQuicktime 和 PDF 在网络上很受欢迎，因为它们是跨平台的，读者可以免费获取。一旦这样的格式建立起来，新格式将很难出现（或者变得同样受欢迎）。\n我发现，出生于互联网上的一个竞争对手是 Netscape。他们的浏览器占主导地位，拥有 70％ 的份额。他们正在寻求一种多平台策略，将关键 API 存放到客户端，以使底层操作系统“商品化”。他们吸引了许多公共网络运营商使用他们的平台提供信息和目录服务。我们必须击败他们。\n下一步我们有很多工作要做。如何协调？我的设想是，Paul Maritz 将领导平台化业务，确保 Windows 系统是互联网用户的最佳选择。这是我们的护城河。Nathan 和 Pete 将领导应用程序和内容小组，弄清楚如何通过为互联网提供应用程序和内容来赚钱。\n关于未来，我认为我们已经具有相当大的优势，最主要的是我们的团队，以及 Windows 和Office 被用户广泛接受。我相信当我们进入互联网业务并且尝试扩展的时候，会有很多不确定性。它会是一股改变了原先规则的潮流，对我们来说，这既是机会，也是挑战。\n\n\n**三个月后，IE 2.0 正式上线，网景和微软的战争就此真正开始。**\n\n随后，1996年8月13日，微软IE3发布。IE 3.0 搭载了一个 JavaScript 的克隆版，叫做 JScript（这样命名是为了避免与 Netscape 潜在的许可纠纷）。微软进军浏览器市场，双方激烈竞争就此展开。网景公司的Netscape Navigator与微软公司的Internet Explorer之间的竞争，后来被称为“浏览器大战”。\n\n\n![](https://www.xr1228.com//post-images/1590287992779.png)\n\n\n>网景和微软的员工不仅暗地里牟足了劲，明面上也剑拔弩张。\n1997 年 10 月，IE 4.0 正式推出，微软在旧金山举行产品发布会，竖起了一个 10 尺长的巨型“e”标志。\n第二天早上，Netscape 的员工们惊讶地发现，这个标志跑到了自家的草坪上，而且上面赫然写上了来自对手的挑衅：“We Love You，From the IE team”。\n这让 Netscape 十分愤怒，他们立刻上前一把推翻对手的标志，然后摆上自己的恐龙吉祥物把微软标志踩在脚下。而且，恐龙手上拿了一个展板，上面写着“Netscape 72, Microsoft 18”（代表当时“ IE 弱 Netscape 强”的市场格局）。\n这种小事只是插曲。随着 IE 4.0 的推广，微软越战越猛，而网景颓势渐显。\n\n![](https://www.xr1228.com//post-images/1590288047894.jpg)\n\n微软步入 Web 浏览器领域的这重要一步虽然令其声名狼藉，但也成为 JavaScript 语言发展过程中的重要一步。\n\n### 五、三足鼎立 与 标准化\n在微软进入后，有 3 种不同的 JavaScript 版本同时存在：Netscape Navigator 3.0 中的 JavaScript、IE 中的 JScript 以及 CEnvi 中的 ScriptEase。与 C 和其他编程语言不同的是，JavaScript 并没有一个标准来统一其语法或特性，而这 3 种不同的版本恰恰突出了这个问题。随着业界担心的增加，这个语言的标准化显然已经势在必行。\n\n1997 年，JavaScript 1.1 作为一个草案提交给欧洲计算机制造商协会（ECMA）。\n\n第 39 技术委员会（TC39）被委派来“标准化一个通用、跨平台、中立于厂商的脚本语言的语法和语义”(http://www.ecma-international.org/memento/TC39.htm)。由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员组成的 TC39 锤炼出了 ECMA-262，该标准定义了名为 ECMAScript 的全新脚本语言。\n\n在接下来的几年里，国际标准化组织及国际电工委员会（ISO/IEC）也采纳 ECMAScript 作为标准（ISO/IEC-16262）。从此，Web 浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。\n\n六、ECMAScript\nECMA-262第 1 版(1997年6月)本质上与 Netscape 的 JavaScript 1.1相同——只不过作了一些较小的改动：\n\n1. 删除了所有针对浏览器的代码。\n2. 支持 Unicode标准（从而支持多语言开发）。\n3. 对象与平台无关（Netscape JavaScript 1.1的对 象在不同平台中的实现不一样，例如 Date 对象）。\n\n\n>这三条规则奠定了JavaScript的可移植性，比如现在比较火爆的node.JS，是一门服务端语言。试想一下如果JavaScript的特性与特定的浏览器绑定的话，前端将是多么混乱的世界。所以，站的高度不同，分析问题的角度，解决问题的角度也会不同，这就是传说中的格局？\n\n这也是 JavaScript 1.1和 1.2与 ECMA-262第 1版不一 致的主要原因。\n\n**ECMA-262第 2 版(1998年8月)** 主要是编辑加工的结果。这一版中内容的更新是为了与 ISO/IEC-16262保持严格 一致，没有作任何新增、修改或删节处理。因此，一般不使用第 2版来衡量 ECMAScript实现的兼容性。\n\n**ECMA-262第 3 版(1999年12月)**才是对该标准第一次真正的修改。修改的内容涉及字符串处理、错误定义和数 值输出。这一版还新增了对正则表达式、新控制语句、try-catch 异常处理的支持，并围绕标准的 国际化做出了一些小的修改。\n从各方面综合来看，第 3版标志着 ECMAScript成为了一门真正的编程 语言。\n\n**ECMA-262第 4 版**对这门语言进行了一次全面的检核修订。由于 JavaScript在 Web 上日益流行，开 发人员纷纷建议修订 ECMAScript，以使其能够满足不断增长的 Web 开发需求。作为回应，ECMA TC39 重新召集相关人员共同谋划这门语言的未来。结果，出台后的标准几乎在第 3版基础上完全定义了一门 新语言。\n\n\n>第 4版不仅包含了强类型变量、新语句和新数据结构、真正的类和经典继承，还定义了与数据 交互的新方式。 与此同时，TC39下属的一个小组也提出了一个名为 ECMAScript 3.1的替代性建议，该建议只对这 门语言进行了较少的改进。这个小组认为第 4版给这门语言带来的跨越太大了。因此，该小组建议对这门语言进行小幅修订，能够在现有 JavaScript引擎基础上实现。\n这也是为什么我们查阅的有关JavaScript资料时，从来没看到过在第四版定义过什么属性或者方法，都是在ES3、ES5中定义的，但也不能说ES4就是废弃物了，现在流行的ES6的原型就是ES4。\n\n终，ES3.1附属委员会获得的支持超过 了 TC39，ECMA-262第 4版在正式发布前被放弃。\n\nECMAScript 3.1成为 ECMA-262第 5版，并于 2009年 12月 3日正式发布。\n\nECMA-262第 5 版(2009年12月)力求澄清第 3 版中已知的歧义并增添了新的功能。新功能包括原生 JSON对象（用于解析和序列化 JSON数据）、继 承的方法和高级属性定义，另外还包含一种严格模式，对 ECMAScript引擎解释和执行代码进行了补充 说明。\n\n![](https://www.xr1228.com//post-images/1590288916841.png)\n\n\n### 七、鹿死谁手？\n这是一场从一开始就不公平的对决。\n\n微软始终拥有两大优势：\n第一，财力雄厚。Netscape 浏览器虽然一度达到 90% 以上的占有率，但网景公司规模不大，加上只有浏览器及相关产品，总收入拍马也赶不上微软。\n第二，Windows 早就垄断了操作系统市场。就算 IE 在早期的评价不如 Netscape，微软只要把 IE 和 Windows 捆绑销售，就可以迅速提升市占率。再加上 IE 的免费政策，只要等到 IE 产品功能和 Netscape 差不多了，大多数用户自然会逐渐放弃 Netscape，转向 IE。\n\n>凭借这两个优势，微软的策略也是妙招不断：\n1、切断 Netscape 财源。既然 Netscape 通过销售服务器软件来发布浏览器赚钱，那么微软也开发类似的产品，而且专门往便宜了卖，积极开打价格战。\n2、看重市场推广。在授权 Windows 给其他主机厂商的时候，微软要求对方必须在桌面展示 IE 的图标，不能加入 Netscape，否则就以涨价威胁。\n3、统一战线。把中小型 ISP（网络提供商）、电信运营商都拉入战局，要求他们以 IE 作为主接口，鼓励用户改用 IE 浏览器。\n4、布局产业上下游。积极收购知名网页设计工具（比如 FrontPage），故意加入非标准的专属标签，使得作出的网页只适用于 IE 浏览器。\n这些手段刀刀命中要害，再加上网景后来在商业决策上犯了错，Netscape 终于在 1998 年年底被 IE 击败。\n至此，网页浏览器之争的第一阶段落下帷幕，美国在线（AOL）以 42 亿美元收购网景业务为这场战争划下终点。再往后，IE 逐步成为浏览器市场的霸主，其份额最高达到 2002 年的 96%，比 Netscape 的顶峰还高。\n\n面对微软的强大威胁，Netscape在1998年11月决定将软件免费、且公开所有的程序源码，将主要力量放在商业市场。这个措施几乎还没来得及实施， Netscape就被AOL美国在线所收购。\n\n不过，AOL并非是想开发浏览器同微软的IE竞争，而是将它作为对微软的反垄断案的一个筹码。之后， Netscape虽然陆续发展出4.X、6.X系列乃至7.X系列，但都毫无影响力可言。\n\n微软与AOL的反垄断官司在2003年5月完结， Netscape项目在7月份就被AOL冻结并将大部分Netscape 开发人员解雇，到此为止属于Netscape的时代就完全结束了。\n\n不过AOL还是作了一件好事，所有的Netscape原始代码被送给开源社群自行开发，同时协助成立了非盈利性的“Mozilla基金会（Mozilla Foundation）”，它也是现在Firefox浏览器的管理和推进组织。\n\n> 现在很多的浏览器都是以之为雏形开发设计的。为了向其致敬，chrome、safari等浏览器代码里都有Browser name: Netscape。\n\n\n### 八、可喜可贺\n到了 2008年，五大主流 Web 浏览器（IE、Firefox、Safari、Chrome和 Opera）全部做到了与 ECMA-262兼容。IE8是第一个着手实现 ECMA-262第 5版的浏览器，并在 IE9中提供了完整的支持。Firefox 4也 紧随其后做到兼容。下表列出了 ECMAScript受主流 Web 浏览器支持的情况。\n\n![](https://www.xr1228.com//post-images/1590289062349.png)\n\n> IE也有他功绩的一面\n1、IE4 中率先使用了ajax的模式，写法为 new ActiveXObject(\"Microsoft.XMLHTTP\");\n2、IE8 是第一个实现 Object.defineProperty()方法的浏览器版本。然而，这个版本的实现存在诸多限制：只能在 DOM对象上使用这个方法，而且只能创建访问器属性。由于实现不彻底，建议读者不要在 IE8 中使用 Object.defineProperty() 方法。 你是否了解Vue实现双向数据绑定的原理？\n但是，他做的恶事绝对比他做的好事要多得多\n\n2015年3月，微软确认将放弃IE品牌，代号为“Project Spartan”的新版浏览器被正式命名为“Microsoft Edge”，但IE仍会存在于某些版本的Windows 10中。\n\n2016年1月13日（美国时间12日），微软停止为IE8/9/10这些旧版本的IE 浏览器提供技术支持。微软也最后一次放出了一个更新文件包（KB3123303)，里面含有安全更新和“寿终正寝” 的升级提醒。\n\n2018年12月6日上午9点，微软通过其博客官方宣布：未来将采用 Chromium 内核开发桌面版 Edge 浏览器，以便为用户带来更好的 Web 兼容性，并为所有 Web 开发者减少 Web 碎片化。因此，微软计划成为 Chromium 项目的“重要贡献者”。\n\n>采用 Chromium 意味着微软将用 Blink 渲染引擎替代自己的 EdgeHTML 引擎，用 V8 替代 Chakra JS 引擎。在 Android 上微软将使用 Blink/Chromium，而 iOS 上将使用 WebKit/WKWebView。对于使用 EdgeHTML 或 Chakra 的 Windows 10 应用，它们可以暂时保持现状，微软最终会向它们提供 Edge 采用的 Chromium 方案。开发者现在可以继续采用旧的方案或切换到 Chromium。\n微软还计划将 Edge 浏览器引入 macOS 平台。此外，新版 Edge 可运行在所有受支持的 Windows 版本上，包括 Windows 7 和 Windows 8 系列 —— 直到微软终止支持，而不仅仅是 Windows 10。\n所以在更新频率方面，Edge 浏览器会与 Windows 10 的更新分离。\n\n\n### 最后的最后\n\n到底谁赢了？Netscape丢掉了市场份额，但基于Netscape诞生了Chromium，微软如今也将Edge内核置换为Chromium。\n或许程序员的世界本就没有永恒的赢家，封闭的生态终将失去群众，拥抱开源才能让技术保持旺盛的生命力。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【前端拾遗】JS的历史",
        "date": "2020-05-24 08:51:05",
        "tags": [
          "前端拾遗",
          "值得一读"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/jsHistory.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "> 一切软件，终将用JS再实现一遍。",
      "fileName": "jsHistory"
    },
    {
      "content": "\n本文将从前端面试题目出发,总结HTML必须掌握的知识点.\n<!-- more -->\n\n### 1.前端开发应该注意那些SEO\n\n- 知识点：SEO\n- 重要程度：★★★\n\n#### SEO的概念\nSEO(Search Engine Optimization) 搜索引擎优化，是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。\n\n- 合理设置 title，discripition，keywords：搜索对着三项的权重逐个减小。\n    - title强调重点即可，重要关键词不要超过2个，不同页面title要有所不同\n    - descripition把页面内容高度概括，长度适合，不同页面descripition不同\n    - keywords 列出关键词即可\n- 语义化的HTML代码\n- 重要的内容放在HTML前面\n- 重要内容不要使用JS输出\n- 提高网站访问速度\n- 非装饰性图片增加alt\n\n### 2.从输入url到浏览器渲染出页面发生了什么\n\n- 知识点：DNS、页面渲染机制等\n- 重要程度：★★★\n\n1. 浏览器将URL交给DNS域名解析（现查找缓存，然后在DNS服务器递归查找）找到真实IP。\n2. 浏览器向服务器发出请求，简历TCP/IP连接。\n3. 服务器交给后台处理完成后的数据，浏览器接收文件\n4. 浏览器对加载的资源进行解析，简历DOM树，解析CSS后生成Render树\n5. 渲染页面\n\n\n### 3.HTML5 有哪些新的特性\n\nHTML5不再是SGML的子集，而是根据现代WEB应用的需求发展出了关于图像、多媒体、位置、存储、多任务处理等功能。其主要有以下新特性\n\n####元素\n- 新增了一些媒体控制元素  video和audio\n- 新增了绘画 canvas\n- 增加了一些语义化更好的标签  article footer header nav section\n- 新增了一些表单控件：canlendar date time email url search\n- 移除了一些元素\n    - 纯表现的元素  big center font 。。。\n    - 可用性具有负面影响的元素  frame  frameset noframes\n####数据保存\n-   新增localstorage长期保存数据\n-   新增 sessionStorage 浏览器关闭后自动删除\n####离线WEB应用\n页面缓存指的还是有网络状态下，而离线web应用指的是在没有网络状态可以运行应用。manifest文件是核心，记录着哪些资源文件需要离线应用缓存，要使用manifest，只需要在html标签中添加属性\n```html\n<html manifest=\"cache.manifest\">\n```\ncache.manifest的文件格式如下\n```vim\n    CACHE MANIFEST\n    #缓存的文件\n    index.html\n    test.js\n    #不做缓存\n    NETWORK\n    /images/\n    FALLBACK\n    offline.html index.html\n```\n缓存的文件下面是当网络不可用时，文件直接从本地缓存读取，\nNETWORK下面的文件无论是否已经缓存，都要从网络中下载。\nFALLBACK后面，当无法获取到offline.html，则转到index.html。\n\n####地理定位\nh5提供了Geolocation API访问地理位置，即通过window.navigator.geolocation来实现访问。这个对象有三个方法：\n```javascript\n    getCurrentPosition()\n    watchPosition()\n    clearWatch()\n```\n页面第一次使用这个api需要获得用户许可, watchPosition可以对位置变化事件进行监听。\n\n### 4.W3C标准\n- 知识点：W3C标准\n- 重要程度：★★★★★\n#### W3C指定的WEB页面标准\n- 标签闭合\n- 标签小写\n- 不乱嵌套\n- 使用外链css和js\n- 结构行为与表现分离\n\n### 5.html语义化是什么？\n- 重要程度：★★★\n\n1.利于用户阅读，样式丢失时仍然能让页面呈现清晰的结构。\n2.利于SEO，搜索引擎是根据标签来确定上下文和关键字的权重\n3.便于其他设备解析，如盲人阅读器根据语义渲染网页\n4.利于开发和维护，语义化代码更佳具有可读性，与CSS3关系更和谐\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【前端拾遗】HTML相关知识点",
        "date": "2020-05-23 21:06:33",
        "tags": [
          "前端拾遗"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/htmlpoint.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n本文将从前端面试题目出发,总结HTML必须掌握的知识点.",
      "fileName": "htmlpoint"
    },
    {
      "content": "\nCSS 作为构建前端页面的三驾马车,随着现代前端技术的飞速发展,已经称为描述页面样式不可或缺的部分. 本文将从前端面试题目出发,总结CSS必须掌握的知识点.\n<!-- more -->\n\n\n# Questions\n\n### 1. css sprite是什么?有什么优缺点?\n\n- 知识点:css sprite\n- 重要程度:★★★\n- 概念与背景: css sprite是一种用于解决页面图片过多导致大量http请求的解决方案. css sprite将多个小图片拼接到一个图片中，通过background-positon 和元素尺寸调节需要显示的背景图案.\n- 优点:\n    - 减少HTTP请求数,极大的提高页面加载速度\n    - 增加图片信息重复度,提高压缩比,减少图片大小\n    - 更换风格方便.只需要在少量图片上修改颜色或者样式即可\n- 缺点:\n    - 图片合并麻烦\n    - 维护不便,修改一个图片可能需要重新布局整个图片样式\n\n- 实现 (转自MDN教程):\n  如果为类名为toolbtn的元素附加一张图片\n ```css\n.toolbtn{\n    background:url(myfile.png);\n    display : inline-block;\n    height : 20px;\n    width : 20px;\n}\n ```\n为设置 background-position 以使每个按钮得到合并后图片中的正确部分，可以在 background 属性中的 url() 后添加 x, y 两个坐标值，或直接使用 background-position 属性。例如：\n\n ```css\n#btn1 {background-position: -20px 0px}\n#btn2 {background-position: -40px 0px}\n ```\n\n 这会将 ID 为 btn1 的元素的背景向左移 20px，ID 为 btn2 的元素的背景向左移40px（假设这两个元素都带有 toolbtn 这个类且应用了上面 background 属性中定义的图片背景）\n\n类似的，你也可以使用下面的代码添加悬停效果：\n```css\n#btn:hover {\n  background-position: <pixels shifted right>px <pixels shifted down>px;\n}\n```\n\n\n### 2. display:none 与 visibility:hidden 的区别\n\n- 知识点: display与visibility\n- 重要程度:★★\n- 概念与背景: 本题考察display与visibility的渲染机制\n- display:none; :\n    - 会让元素完全从渲染树中消失,渲染时不占任何空间\n    - 非继承属性: 子孙节点同样消失,无法通过修改子孙节点属性使子孙节点显示\n- visibility:hidden; :\n    - 不会让元素从渲染树中消失,渲染时仍然占据控件,只是内容不可见\n    - 子孙节点可以通过重新设置 visibility:visible; 使自身显示\n    - 修改display属性会导致文档重拍,visibility只会导致内容重新渲染\n\n\n\n### 3.CSS的选择器 \n- 知识点: CSS的样式选择器\n- 重要程度:★★★★\n- 概念与背景: CSS 选择器规定了 CSS 规则会被应用到哪些元素上。CSS选择器是构建前端页面样式最基础也是最重要的部分\n\n> 备注：暂时没有能够选择 父元素、父元素的同级元素，或 父元素的同级元素的子元素 的选择器或者组合器。\n\n这里列举部分常见CSS元素选择器的使用方法\n\n```html\n<div id=\"box\" class=\"myBox\">\n    <p title=\"value\">This is a P tag</p>\n    <button class=\"myBtn\">Click</button>\n\n    <p>This is a P tag2</p>\n</div>\n```\n\n```css\n/* 类选择器 */\n.myBox{  backgournd-color:red;  }\n/* id选择器 */\n#box{backgournd-color:red;}\n/* 元素选择器 */\np{backgournd-color:yellow;}\n/* 组合选择器 */\np, button  {backgournd-color:yellow;}   /* 多个元素为平行关系,都获得该样式属性 */\n/* 后代选择器 */\n.myBox .myBtn{ background-color:green; }  /* .myBox中的所有.myBtn  用空格隔开 */\n/* 子选择器 */\n.myBox > .myBtn{ background-color:green; }  /* .myBox中的所有.myBtn子元素  用>隔开 */\n/* 相邻选择器 */\np + .myBtn{ background-color:green; }  /* p后相邻的.myBtn同级元素*/\n/* 同级通配符 */\np ~ btn { background:#ff0; }  /* p后所有同级的btn元素  CSS3*/  \n\n/* 伪类 */\n.myBox:first-child { font-style:italic; }  /* mybox的第一个子元素*/  \n.myBtn:hover { background-color:green; }  /* mybox的第一个子元素*/  \n\n/* 元素选择器 */\np[title] { color:#f00; }  /*具有title属性的P标签*/  \np[title=value] { color:#f00; }  /*具有title属性且属性内容为value的P标签*/  \n```\n\n- 关于选择器的权重：\n    - 选择器类型：\n    1、ID　　#id\n    2、class　　.class\n    3、标签　　p\n    4、通用　　*\n    5、属性　　[type=\"text\"]\n    6、伪类　　：hover\n    7、伪元素　　::first-line\n    8、子选择器、相邻选择器\n \n    - 权重计算规则：\n    1、第一等：代表内联样式，如: style=””，权值为1000。\n    2、第二等：代表ID选择器，如：#content，权值为0100。\n    3、第三等：代表类，伪类和属性选择器，如.content，权值为0010。\n    4、第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。\n    5、通配符、子选择器、相邻选择器等的。如*、>、+,权值为0000。\n    6、继承的样式没有权值。\n\n- 附：选择器使用方法\n\n![](https://www.xr1228.com//post-images/1590135976965.png)\n![](https://www.xr1228.com//post-images/1590135990176.png)\n\n\n\n### 4.清除浮动有哪些方法？ \n- 知识点: 清除浮动，BFC\n- 重要程度:★★\n- 概念与背景: 清除浮动其实就是为了解决父元素内的子元素设置浮动后导致的父元素内部高度为0的问题。\n如图：父元素内有两个子元素 BIG、SMALL。当子元素未设置浮动时子元素会自动撑开父元素高度。\n\n![](https://www.xr1228.com//post-images/1590204347700.png)\n\n当子元素设置Float属性后，父元素高度变为0，且外部元素位置也发生了改变。\n\n![](https://www.xr1228.com//post-images/1590204463221.png)\n\n#### 清除浮动的方法：\n1.  额外标签法：（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐）\n        -   优点：方便，通俗易懂\n        -   缺点：增加无意义的标签\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    body {\n      font-size: 30px;\n    }\n    .father {\n      background-color: bisque;\n      border: red solid 1px;\n    }\n    .big {\n      float: left;\n      height: 400px;\n      width: 400px;\n      background-color: pink;\n    }\n    .small {\n      float: left;\n      height: 200px;\n      width: 200px;\n      background-color: blue;\n    }\n    .clear {\n      clear: both;\n    }\n    .other {\n      height: 200px;\n      background-color: green;\n      ;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"father\">\n    <div class=\"big\">BIG</div>\n    <div class=\"small\">SMALL</div>\n    <div class=\"clear\"></div>\n  </div>\n  <div class=\"other\"></div>\n</body>\n</html>\n```\n2. 触发BFC：父级添加overflow属性（父元素添加overflow:hidden）（不推荐）\n这里要说明一下BFC，\n> BFC（Block formatting context）：块级格式化上下文，BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。\n\n通俗来讲，BFC是HTML的一种特性，**只要触发了BFC，一个块级元素就形成了一个封闭空间。这个空间内的子元素排布不会对外部元素发生影响。**\noverflow是触发BFC的一个条件，我们利用这个条件就可以让父级形成BFC。\n**触发BFC的条件：**\n1、float的值不是none。\n2、position的值不是static或者relative。\n3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex\n4、overflow的值不是visible\n\n    -  优点：代码简洁\n    -  缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素\n\n```css\n    .father {\n      background-color: bisque;\n      border: red solid 1px;\n      overflow:hidden;\n    }\n```\n3. 使用after伪元素清除浮动（推荐）\n- 优点：符合闭合浮动思想，结构语义化正确\n- 缺点：after是css3提出的伪类，兼容IE6-7需要使用zoom:1 触发hasLayout\n\n```css\n    .clearfix:after{ /*伪元素是行内元素 正常浏览器清除浮动方法*/\n        content: \"\";\n        display: block;\n        height: 0;\n        clear:both;\n        visibility: hidden;\n    }\n    .clearfix{\n        *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/\n    }\n```\n ```html\n<body>\n    <div class=\"fahter clearfix\">\n        <div class=\"big\">big</div>\n        <div class=\"small\">small</div>\n        <!--<div class=\"clear\">额外标签法</div>-->\n    </div>\n    <div class=\"other\"></div>\n```\n\n\n4. 使用before和after双伪元素清除浮动\n- 优点：符合闭合浮动思想，结构语义化正确\n- 缺点：after是css3提出的伪类，兼容IE6-7需要使用zoom:1 触发hasLayout\n```css\n\n     .clearfix:after , .clearfix:before{\n        content: \"\";\n        display: table;\n    }\n    .clearfix:after{\n        clear: both;\n    }\n    .clearfix{\n        *zoom: 1;\n``````\n\n### 5. CSS3有哪些改变？\n- 知识点: CSS3变化\n- 重要程度:★★★★\n\n#### CSS3带来的一些变化：\n\n- 新增了一些选择器\n    - p:first-of-type 选择属于其父元素的首个P元素\n    - p:last-of-type 选择属于其父元素的最后一个P元素\n    - p:only-of-type 选择属于其父元素的唯一个P元素\n    - p:only-child 选择属于其父元素的唯一个P元素\n    - p:nth-child(2) 选择属于其父元素的第二个子元素的P元素\n    - after：在元素之后添加内容，可以用来清除浮动\n    - before：在元素之前添加内容\n    - enable，disable，checked\n  \n- 增加了对于动画、图形处的处理\n    - transition：过度\n    - transform：旋转、缩放、移动或倾斜\n    - animation：动画\n    - gradient：渐变\n    - shadow：阴影\n    - border-radius：圆角\n\n### 6.浏览器是如何解析CSS选择器的？\n\nCSS选择器是从右向左解析的，如果从左向右解析发现不匹配则需要回溯，会损失许多性能。从右向左解析先找到最右节点，向上寻找其父节点直到找到根元素。\nCSS解析完成后，需要与Dom Tree一起分析简历Render Tree，最后进行绘图。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【前端拾遗】CSS知识点",
        "date": "2020-05-21 10:55:48",
        "tags": [
          "前端拾遗"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/CSS-Point.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\nCSS 作为构建前端页面的三驾马车,随着现代前端技术的飞速发展,已经称为描述页面样式不可或缺的部分. 本文将从前端面试题目出发,总结CSS必须掌握的知识点.",
      "fileName": "CSS-Point"
    },
    {
      "content": "\n\n\n> 2014 - 2020 ，两千多个披星戴月，收获良多。对个人负责、参与过的项目进行总结如下。\n\n\n## 项目一： 设备智能管理系统（桌面应用程序）\n\n- 项目描述：一套以发挥数据潜能为核心的智能制造解决方案。主要用于解决当前工厂生产运营中存在的人力、效率、方法、数据价值相关问题，最终帮助工厂向工业4.0转型。\n\n- 个人工作职责：项目负责人，负责项目需求制定、程序开发、资源协调与业务推进。\n\n- 实现技术：BS/CS混合架构 + .NET Winform + MS SQL Server + LinQ + SpringBoot(部分ServerAPI)；\n\n\n  \n![](https://www.xr1228.com//post-images/1589153255940.png)\n\n- 主要模块：设备监控、工艺监控、不良调查\n>   ![](https://www.xr1228.com//post-images/1589153107363.png)\n\n>   ![](https://www.xr1228.com//post-images/1589153172425.png)\n\n>   ![](https://www.xr1228.com//post-images/1589153182823.png)\n\n- 项目难点：\n\n    1. UI 样式 ：Winform作为一款20年前推出的框架，组件UI样式已经显得十分“呆板落伍”。\n    - 解决方案：通过对 MetroFramework 框架的定制开发，实现了样式设计的现代化同时兼具Winform拖动组件设计的便捷性。\n![](https://www.xr1228.com//post-images/1589154078440.png)\n\n    2. 代码执行效率：工业级应用在数据分析过程中要快速处理大量数据（M级），BS架构会极大增加服务器压力，CS架构下用户对于程序卡顿感知较强。\n\n    - 解决方案：数据处理在客户端执行，保证了代码执行效率减少服务器开销。大量使用了多线程方案优化用户体验。\n\n\n## 项目二： 数据透明化平台（Web）\n\n- 项目描述：一套用于工厂数据可视化、展示固定报表，数据监控的Web应用。解决用户复杂的数据处理加工需求，减少重复低效的数据二次处理劳动。固化日报月报，帮助技术部获取实时数据。\n\n- 个人工作职责：全栈开发，主要进行项目的需求检讨与开发。\n\n- 实现技术：AngularJS + SpringBoot + Oracle + Primeng + echarts + d3js\n\n![](https://www.xr1228.com//post-images/1589154673790.png)\n\n## 项目三：基于大数据技术的不良分析平台\n\n- 项目描述：一个基于大数据技术的不良分析平台，将工业生产数据与检测数据进行全面联动，采用特定算法计算影响不良的相关因子，明确不良发生原因。为工厂提供不良监控、自主分析等功能。\n\n- 个人工作职责：项目支援，主要进行项目的前端开发、性能调优。\n\n- 实现技术：AngularJS + SpringBoot + 。。。（保密协议相关）\n\n\n## 项目四：小程序（篇幅有限，将几款小程序合并一起说明）\n\n- 智造之窗：一款用于企业智能制造项目改进、移动端数据展示、新闻、数据交互的微信小程序。\n- i创+提案平台：一款用于企业改善提案上报、审批、数据展示的微信小程序。\n- 全员学习系统：用于单位全员学习、考试、学习情况评比、学习心得展示的钉钉小程序。\n- 资产名片：用于企业固定资产管理、二维码标签自动生成、资产审批的微信小程序。\n- 绩效时钟：用于单位全员绩效管理、任务分解、任务下发的微信小程序。\n\n- 实现技术：小程序原生框架 + Koa2（Nodejs） + MySQL\n\n![](https://www.xr1228.com//post-images/1589385069512.png)\n\n- 项目难点：\n  1. 服务中台：小程序项目具有轻量化、数量多、基本数据(用户信息）一致的特点，为了保障应用的快速开发上线，减少重复代码。将人员信息、项目配置信息、页面配置等进行了服务端中台化。\n  2. UI组件：为保障项目统一性与页面美观，基于ColorUI开发了XRUI框架。通过template与css方式在保障项目美观的同时兼顾了框架的易用性与可拓展性。\n   1. 移动端数据展示：小程序端因为其特定的框架结构，Echarts等可视化工具无法直接使用。采用Canvans方式对echarts进行了定制化（基于echarts for wx）保障了移动端数据可视化功能的执行效率。\n\n![](https://www.xr1228.com//post-images/1589157404629.png)\n\n## 项目五：房车情报（已下线）\n\n- 项目描述：一个为房车情报官方设计的房车展示、新闻展示、车型数据库网站。\n\n- 个人工作职责：项目负责人，负责项目需求制定、程序开发。\n\n- 实现技术：bootStrap + vue + koa2（nodejs） + mySql + sequelize\n\n- 项目难点：\n  1. 静态资源优化：新闻类咨询类网站存在大量静态资源且通常图片尺寸较大。采用Gzip压缩、上传压缩、CDN等方式实现了静态资源的尺寸、访问速度优化。\n  2. 首屏加载与SEO优化：单页应用存在首屏加载与SEO问题，通过首页服务度渲染、组件懒加载、Gzip、h5语义化标签等方式对其进行了优化。\n\n![](https://www.xr1228.com//post-images/1589157977232.jpeg)\n\n\n-------\n\n\n\n###  附：个人简历\n\n![](https://www.xr1228.com//post-images/1589125473530.jpg)\n\n![](https://www.xr1228.com//post-images/1589125514909.jpg)\n",
      "data": {
        "title": "我做过哪些项目？",
        "date": "2020-05-10 23:33:14",
        "tags": [
          "值得一读"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/xiangmu.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "xiangmu"
    },
    {
      "content": "\n\n## 1. 实现盒子水平垂直居中的几种方案？\n解答：\n\n实现盒子水平垂直居中在flex提出之前，最常用的方法是通过position定位实现，主要有三种方式：\n\n- 方式一: 通过相对父级容器进行定位，缺点:必须知道box的宽高\n```css\nbody{\n    height:100%\n    overflow:hidden;\n    position:relative;  \n}\n.box{\n    width:100px;\n    height:50px;\n    position:absolution;\n    margin-top:-25px;    /* 移动半个box */\n    margin-left:-50px;\n}\n```\n\n- 方式二：缺点：可以不知道box的宽高，但box必须定义宽高\n\n```css\nbody{\n    height:100%\n    overflow:hidden;\n    position:relative;  \n}\n.box{\n    width:100px;\n    height:50px;\n    position:absolution;\n    top:0;    \n    left:0;  \n    right:0;\n    bottom:0;\n    margin:auto 0;  \n}\n```\n\n- 方式三  无需考虑box的宽度与高度，缺点：低版本浏览器兼容性不太好\n\n```css\nbody{\n    height:100%\n    overflow:hidden;\n    position:relative;  \n}\n.box{\n    position:absolution;\n    top:50%;    \n    left:50%;  \n    transform:translate(-50%,-50%);   /* css3中移动位置  */\n}\n```\n\n采用弹性盒子模型后可以使用如下方式：\n\n```css\nbody{\n    height:100%;\n    display:flex;\n    justify-content : center;  //水平居中\n    align-items : center;   //垂直居中\n}\n```\n\n\n还能采用JS来实现盒子模型\n\n```html\n<body>\n    <div class=\"box\">\n    </div>\n    <script>\n        let HTML = document.documentElement,\n            winW = HTML.clientWidth,\n            winH = HTML.clientHeight,\n            boxW = box.offsetWidth\n            boxH = box.offsetHeight;\n        box.style.postion = \"absolution\";\n        box.style.left = winW-boxW)/2 + 'px';\n        box..style.top = ()\n    </script>\n</body>\n```\n``` css\nbody{\n    position:relative;\n}\n\n```\n\n## 2. 盒子模型相关\n\n- 盒子模型分为 ：\n    - 标准盒子模型    box-sizing:content-box\n    - 怪异盒子模型（也就是IE盒子模型）   box-sizing:border-box \n    - 弹性伸缩布局盒子模型（flex）\n\n>标准盒子模型width与height指定的是content的宽高。标准盒子模型有一个明显的缺陷，当我们修改border或padding后盒子整体实际宽高会发生变化，这就会整体页面布局出错。而怪异盒子模型的width与height是盒子整体的宽高，修改其padding与border盒子会自动伸缩content。目前主流的bootstrap等ui组建大部分默认采用了怪异盒子模型。\n\n![](https://www.xr1228.com//post-images/1589074776615.png)\n\n\n![](https://www.xr1228.com//post-images/1589074963770.png)\n\nFLEX盒模型 ：为布局实现提供了灵活性\n\n![](https://www.xr1228.com//post-images/1589075004652.png)\n\n\n## 3.经典布局方案\n\n圣杯布局 ： 左右固定,中间自适应 (双飞翼布局与之类似，不做详细讨论了).圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。\n\n![](https://www.xr1228.com//post-images/1589077300019.png)\n\n实现圣杯布局的要求\n- header和footer各自占领屏幕所有宽度，高度固定。\n- 中间的container是一个三栏布局。\n- 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。\n- 中间部分的高度是三栏中最高的区域的高度。\n\n\n圣杯布局的三种实现方式\n\n1. 浮动\n\n- 先定义好header和footer的样式，使之横向撑满。\n- 在container中的三列设为浮动和相对定位(后面会用到)，center要放在最前面，footer清除浮动。\n- 三列的左右两列分别定宽200px和150px，中间部分center设置100%撑满\n- 这样因为浮动的关系，center会占据整个container，左右两块区域被挤下去了\n- 接下来设置left的 margin-left: -100%;，让left回到上一行最左侧\n- 但这会把center给遮住了，所以这时给外层的container设置 padding-left: 200px;\n- padding-right: 150px;，给left和right空出位置\n- 这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过 left: -200px; 把left拉回最左侧\n- 同样的，对于right区域，设置 margin-right: -150px; 把right拉回第一行\n- 这时右侧空出了150px的空间，所以最后设置 right: -150px;把right区域拉到最右侧就行了\n\n```html\n<html>\n\n<style>\n  body {\n    min-width: 550px;  /* 2x leftContent width + rightContent width */\n    font-weight: bold;\n    font-size: 20px;\n  }\n \n  #header, #footer {\n    background: rgba(29, 27, 27, 0.726);\n    text-align: center;\n    height: 60px;\n    line-height: 60px;\n  }\n  #footer {\n    clear: both;\n  }\n \n  #container {\n    padding-left: 200px;   /* leftContent width */\n    padding-right: 150px;  /* rightContent width */\n    overflow: hidden;\n  }\n \n  #container .column {\n    position: relative;\n    float: left;\n    text-align: center;\n    height: 300px;\n    line-height: 300px;\n  }\n \n  #center {\n    width: 100%;\n    background: rgb(206, 201, 201);\n  }\n \n  #left {\n    width: 200px;           /* leftContent width */\n    right: 200px;           /* leftContent width */\n    margin-left: -100%;\n    background: rgba(95, 179, 235, 0.972);\n  }\n \n  #right {\n    width: 150px;           /* rightContent width */\n    margin-right: -150px;   /* rightContent width */\n    background: rgb(231, 105, 2);\n  }\n \n</style>\n \n<body>\n  <div id=\"header\">#header</div>\n  <div id=\"container\">\n    <div id=\"center\" class=\"column\">#center</div>\n    <div id=\"left\" class=\"column\">#left</div>\n    <div id=\"right\" class=\"column\">#right</div>\n  </div>\n  <div id=\"footer\">#footer</div>\n \n \n</body>\n \n</html>\n\n```\n\n\n2. Flex弹性盒子\n\n- header和footer设置样式，横向撑满。\n- container中的left、center、right依次排布即可\n- 给container设置弹性布局 display: flex;\n- left和right区域定宽，center设置 flex: 1; 即可\n\n```html\n\n<!DOCTYPE html>\n<html>\n<style>\n  body {\n    min-width: 550px;  \n    font-weight: bold;\n    font-size: 20px;\n  }\n  #header, #footer {\n    background: rgba(29, 27, 27, 0.726);\n    text-align: center;\n    height: 60px;\n    line-height: 60px;\n  }\n  #container {\n   display: flex;\n  }\n  #container .column {\n    text-align: center;\n    height: 300px;\n    line-height: 300px;\n  }\n  #center {\n    flex: 1;  /*  自动占用剩余所有空间 */\n    background: rgb(206, 201, 201);\n  }\n  #left {\n    width: 200px;        \n    background: rgba(95, 179, 235, 0.972);\n  }\n  #right {\n    width: 150px;           \n    background: rgb(231, 105, 2);\n  }\n</style>\n \n<body>\n  <div id=\"header\">#header</div>\n  <div id=\"container\">\n    <div id=\"left\" class=\"column\">#left</div>\n    <div id=\"center\" class=\"column\">#center</div>\n    <div id=\"right\" class=\"column\">#right</div>\n  </div>\n  <div id=\"footer\">#footer</div>\n</body>\n \n</html>\n``````\n\n\n3.Grid布局\n\n![](https://www.xr1228.com//post-images/1589078133539.png)\n\n如上图所示，我们把body划分成三行四列的网格，其中有5条列网格线\n\n- 给body元素添加display: grid;属性变成一个grid(网格)\n- 给header元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第一行网格的从第一条列网格线开始到第五条列网格线结束\n- 给footer元素设置grid-row: 1; 和 grid-column: 1/5; 意思是占据第三行网格的从第一条列网格线开始到第五条列网格线结束\n- 给left元素设置grid-row: 2; 和 grid-column: 1/2; 意思是占据第二行网格的从第一条列网格线开始到第二条列网格线结束\n- 给center元素设置grid-row: 2; 和 grid-column: 2/4; 意思是占据第二行网格的从第二条列网格线开始到第四条列网格线结束\n- 给right元素设置grid-row: 2; 和 grid-column: 4/5; 意思是占据第二行网格的从第四条列网格线开始到第五条列网格线结束\n\n``` html\n<!DOCTYPE html>\n<html>\n \n<head>\n  <meta charset=\"utf-8\">\n  <script src=\"http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js\"></script>\n</head>\n<style>\n  body {\n    min-width: 550px;\n    font-weight: bold;\n    font-size: 20px;\n    display: grid;\n  }\n  #header,\n  #footer {\n    background: rgba(29, 27, 27, 0.726);\n    text-align: center;\n    height: 60px;\n    line-height: 60px;\n  }\n  #header {\n    grid-row: 1;\n    grid-column: 1/5;\n  }\n  #footer {\n    grid-row: 3;\n    grid-column: 1/5;\n  }\n  .column {\n    text-align: center;\n    height: 300px;\n    line-height: 300px;\n  }\n  #left {\n    grid-row: 2;\n    grid-column: 1/2;\n    background: rgba(95, 179, 235, 0.972);\n  }\n  #center {\n    grid-row: 2;\n    grid-column: 2/4;\n    background: rgb(206, 201, 201);\n  }\n  #right {\n    grid-row: 2;\n    grid-column: 4/5;\n    background: rgb(231, 105, 2);\n  }\n</style>\n \n<body>\n  <div id=\"header\">#header</div>\n  <div id=\"left\" class=\"column\">#left</div>\n  <div id=\"center\" class=\"column\">#center</div>\n  <div id=\"right\" class=\"column\">#right</div>\n  <div id=\"footer\">#footer</div>\n</body>\n \n</html>\n```\n\n## 4.移动端的自适应解决方案\n\n- .media\n- rem\n- flex\n- vh/vw\n- .......\n",
      "data": {
        "title": "【前端拾遗】前端布局方案",
        "date": "2020-05-09 01:02:17",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/qian-duan-mian-shi-bi-kao-ti.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "qian-duan-mian-shi-bi-kao-ti"
    },
    {
      "content": "\n# 一、流计算的必要性\n\n- 流计算的需求\n    - Map-Reduce，Spark，GraphLab都是批处理模型，会面临如下挑战\n        - Volume 数据量太大以至于存不下全部数据（譬如筛选近十年所有的互联网的词）\n        - Velocity 数据的到来太快以至于用批处理方式来不及处理\n        - 使用批处理框架达到所需要性能的成本太高\n\n\n# 二、什么情况下使用流计算\n  \n    F(X+△X) = F(X)op(△X)\n  \n  计算F(X+△X)时不需要对全部数据集 X+△X进行计算，只需要将X之前的某种处理结果保留下来，并和增量△X处理结果再进行处理。这种处理方式可以看做数据不断增量的方式流入系统并处理，改变系统状态并输出结果。我们把这种方式叫做流计算。\n\n  - 举例：Twitter 大规模实时应用\n    - 平均每秒 6000个tweets，每天约5亿\n    - 对这些tweets及相关的点击进行统计\n\n![](https://www.xr1228.com//post-images/1582112459447.PNG)\n\n# 三、流计算的技术挑战\n\n- 流计算的目标\n    - 实时性/可扩展性：\n        - 批处理任务一般对固定规模数据进行处理，执行时间可以长达几十小时（离线）\n        - 流处理\n            - 数据到达速率变化很大（做负载均衡）\n            - 要么能够处理所有的数据\n            - 要么预先定义好降级处理的方法\n    - 容错：系统的错误与系统的故障\n        - 批处理任务\n            - 数据错误通常由数据清洗阶段完成 \n            - 系统故障有重算或检查点设置等机制 （MapReduce：从中间结果开始重新计算）\n        - 流计算\n            - 数据错误必须实施处理\n            - 系统故障时的容错机制必须是低开销的，而且还能满足实时性\n    - 可编程性\n        - 描述自然\n        - 表达力强\n        - 无需关注（或少关注）容错机制和负载平衡\n\n# 四、流计算的一种简单实现  Worker + Queue （处理+缓冲/路由）\n\n- Worker ： 处理单元\n- Queue ： 缓冲 + 路由 → 解决传入分析系统的数据量不均衡的问题\n\n![](https://www.xr1228.com//post-images/1582162418584.PNG)\n\n数据传入后，通过负载均衡随机进入（或遵循一定规则）被分配到不同的Queue（队列）\nQueue中数据全连接到后续的worker，Worker对数据进行处理，制定接下里要进入的Queue\n处理后的Queue与后续的Worker一一对应，解决并发，数据一致性的问题。\n\nWorker  Queue存在不易扩展，难容错，编码复杂的问题，所以Twitter替换了这种方式，采用了Strom\n\n\n# 五、S4 （Simple Scalable Streaming System）\n-   简单的流处理编程接口\n    -   和MapReduce类似，都是处理key-value\n- 有限容错\n    - 系统节点出错后会重新在备用节点上启动进程\n    - 当前进程状态丢失，但支持非协调式检查点\n    - 在运行期间不能增加或删除系统节点\n\n### 5.1 S4的处理模型 —— Actor模型\n\n- PE（Processiong Element）\n- PE之间通过event进行通信\n- PE的状态互不可见\n- S4框架负责产生PE和消息路由\n\n![](https://www.xr1228.com//post-images/1582162821926.PNG)\n\n### 5.2 S4的设计\n\n- 基于（Key，Attribute）流\n- 输入是（K,A）流，S4进行计算，产生中间结果，并（可能）输出一个流\n\n距离：进行wordCount\n![](https://www.xr1228.com//post-images/1582162914721.PNG)\n\nPE\n-   功能 ：由PE的代码和配置文件定义\n-   处理的事件类型\n-   每个Key的值对应一个PE\n    -   在wordcount中，如果遇到一个新词，则会创建一个新的PE\n- PE的垃圾收集是一个挑战性问题\n    - 超时，内存使用情况\n\nProcessing Node\n- PN是一个逻辑概念\n    - 每个PE都在一个PN上\n    - 一个PN包含多个PE\n- S4的路由是先到PN，再到PE\n- PN到无力节点的映射可以修改，因此可以容错\n- 利用Zookepper保存全局信息，协调节点的行为\n\n![](https://www.xr1228.com//post-images/1582163462684.PNG)\n\nS4的编程模型\n```java\nprivate void processEvent(Eventevent ){\n    queryCount+;\n}\npublic void output(){\n    String query = (String)this.getKeyValue().get(0);\n    persister.set(query.queryCount);\n}\n```\n\n```xml\n<bean id=\"queryCounterPE\" class=\"com.company.s4.processor:QueryCounterPE\">\n<property name=\"keys\">\n    <list>\n        <value>QueryEvent queryString</value>\n    </list>\n</property>\n<property name=\"persister\" ref=\"externalPersister\">\n<property name=\"outputFrequencyByTimeBoundary\" value=\"600\"/>\n</bean>\n```\n\n\n# 六、流计算最主流的框架 —— Storm\n\n## 6.1 Storm的实现\n- Tuple（Named list of values）：[:name \"Chen\" :age 40],类似<KEY,VALUE>\n- Storm的基本概念\n    - Stream : Tuple格式的数据流\n    - Spout ：Stream的源头。\n    - Bolt : 类似于Worker，主要的处理单元。\n        - Filters 流的分析筛选\n        - Aggregation  统计，聚合\n        - Joins 将两个流合并\n        - 访问数据库\n        - 运行自定义函数\n    - Topology ： Storm程序被称为Topology\n-  数据类型：Storm已经支持所有的primitive type，用户也可以自己定义对象作为value。\n-  数据连接（Stream Grouping）：Bolts之间相关连接\n    -  Shuffle Grouping 随机\n    -  Field Grouping 根据tuple field的值选取\n    -  All Grouping 发给所有任务\n    -  Global Grouping 发给具有最小id的任务\n\n定义Strom结构的粒子\n```java\nTopologyBuilder builder = new TopologyBuilder();\nbuilder.setSpout(\"words\",new TestWordSpout(),10);\nbuilder.setBolt(\"exclaim1\",new ExclamationBolt(),3).shuffleGrouping(\"words\");\nbuilder.setBolt(\"exclaim2\",new ExclamationBolt(),2).shuffleGrouping(\"exclaim1\");\n//TestWordSpout()\npublic void nextTuple(){\n    Utils.sleep(100);\n    final String[] words = new String[] {\"nathan\",\"mike\",\"jackson\",\"golda\",\"bertels};\n    final Random rand = new Random();\n    final String word = words[rand.nextInt(words.length)];\n    _collector.emit(new Values(word))；\n}\n// ExclamationBolt()\npublic void execute(Tuple tuple){\n    _collector.emit(tuple,new Values(tuple.getString(0)+\"!!!!\"));  //emit的原因是为了后续容错，后面的ack方法使程序知道execute完成了。\n    _collector.ack(tuple);  \n}\n\npublic void declareOutputFields(OutputFieldsDeclarer declarer){\n    declarer.declarer(new Fields(\"word\"));\n}\n```\n\n实现WordCount的 Storm代码实例\n\n```java\npublic static class WordCount implements IBasicBolt{\n    Map<String,Integer> counts = new HashMap<String,Interger>();\n    public void prepare(Map conf,TopologyContext context){\n        //\n    }\n    public void excete(Tuple tuple,BasicOutputCollector collector){\n        String word = tuple.getString(0);  //bolt中包含多个词的计数，先找到某个词的count，取出增加计数后，在重新写入bolt。\n        Integer count = counts.get(word);\n        cont ++ ;\n        conts.put(word,count); \n        collector.emit(new Values(word,count));\n    }\n    public void cleanup(){\n        //\n    }\n    public void declareOutputFields(OutputFieldDeclarer declarer){\n        declarer.declare(new Fields(\"word\",\"count\"));\n    }\n}\n\n运行Storm\n```java\nLocalCluster cluter = new LocalCluster();\nMap conf = new HashMap();\nconf.put(Config.TOPOLOGY_DEBUG,true);  //Debug模式\n\ncluster.submitTopology(\"demo\",conf,builder.createTopology());\n```\n\n## 6.2  Storm的容错\n- 消息的完整处理\n    - 每一条消息至少执行一次 at least once\n    - 通过每条消息 ack()  方法来判断是否完成，如果部分任务没有完成（Timeout）则判断消息没有完整性。为了防止重新计算带来了状态额不一致，采用Transcational（区分计算和提交部分，提交部分按编号传行，计算部分流水线并行）\n\n\n## 6.3 S4和Storm的对比\n\n- 编程模型\n    - S4更简单，编写每个Key的行为就行了\n    - Storm需要保存和处理更多的东西\n- 推还是拉\n    - S4推，如果缓冲区不够消息就会丢失\n    - Storm拉，因此丢失的消息来自最初的数据输入\n- 容错\n    - S4不管消息丢失，但是可以恢复状态\n    - Storm保证消息被处理至少一次\n- 社区\n    - Storm是Apache顶级项目，社区非常活跃，Twitter使用\n    - S4是Apache incubator项目（孵化器），Yahoo使用\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【工业与大数据】流处理 —— 云计算的重要处理模式",
        "date": "2020-02-19 19:28:16",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/gong-ye-yu-da-shu-ju-liu-ji-suan-yun-ji-suan-de-chong-yao-chu-li-mo-shi.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gong-ye-yu-da-shu-ju-liu-ji-suan-yun-ji-suan-de-chong-yao-chu-li-mo-shi"
    },
    {
      "content": "\n# 一、NoSQL运动与Cassandra：\nNoSQL(NoSQL = Not Only SQL )，意即\"不仅仅是SQL\"。NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。2009年，Last.fm的Johan Oskarsson发起了一次关于分布式开源数据库的讨论，来自Rackspace的Eric Evans再次提出了NoSQL的概念，这时的NoSQL主要指非关系型、分布式、不提供ACID的数据库设计模式。\n2009年在亚特兰大举行的\"no:sql(east)\"讨论会是一个里程碑，其口号是\"select fun, profit from real_world where relational=false;\"。因此，对NoSQL最普遍的解释是\"非关联型的\"，强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。\n\n- NoSQL的技术特征\n    - 否定关系模型\n    - 否定ACID事务\n    - 否定SQL语言（某种程度上又回归SQL）\n\nNoSQL主要可以分为三类\n-   Document（文档）：Clusterpoint，Apache CouchDB，Couchbase，MarkLogic，MongoDB\n-   Key-value（键值）：Dynamo，Cassandra，FoundationDB，MemcacheDB，Redis，Riak，Aeropike\n-   Grap（图）：Allegro，Neo4J，InfiniteGraph，OrientDB，Virtuoso，Stardog\n\n## 1.1 Cassandra \n\n![](http://doc.xr1228.com//post-images/1582083836313.PNG)\n\n- Apache Cassandra 是一套开源的分布式NoSQL数据库系统\n- Facebook 开发，用来提升收件箱搜索的特性\n- 2008年7月在Google code上开源\n\n- Cassandra特点与定位\n    - 无单点故障\n    - 高可用性\n    - 可配置的一致性\n- Cassandra使用场景：适合时间追踪与分析\n    - 时间序列数据\n    - 传感器设备数据\n    - 社交媒体分析\n    - 风险分析\n    - 故障分析\n\n\n# 二、Cassandra数据模型\n\nCassandra数据模型借鉴了google Bigdata的数据模型：\n-   键空间 - Keyspace：最上层的命名空间，通常是一个应用程序一个Keyspace， **~=database**\n- 列族 - ColumnFamily：和table并不一样，因为Column Family是稀疏的表\n- 行 Row： 每一行由一个key唯一标示，由columns组成\n- 列 Column：存储的基本单元，它是一个三元组（name，value，timestamp）\n\n![](http://doc.xr1228.com//post-images/1582084090409.PNG)\n\n![](http://doc.xr1228.com//post-images/1582084216424.PNG)\n\n# 三、Cassandra回归SQL的理由\n简单的丢弃SQL极大影响了编程效率\n- Thrift接口\n    - 低层接口：get，get_slice,mutate ....\n    - 直接暴露了内部存储结构（不利于系统升级）\n- CQL2不支持行操作\n- CQL3通过采用复合类型，将KV存储映射到一个更自然的行和列方式表示\n\n ```sql\n  CREATE keyspace testsp WITH replication = {\n      'class':'SimpleStrategy','replication_factor':1\n  };\n  USER testsp;\n  DESCRIBE keyspace testsp;\n  CREATE ColumnFamily users1(id int,user_name varchar,PRIMARY KEY(ID));\n  INSERT INTO users1(id,user_name)Values(1,'abc');\n  UPDATE USERS SET user_name = '2025' WHERE id = 1;\n  DELETE FROM users WHERE id =1 ;\n  SELECT * FROM users1 ;\n  ```\n可以看出目前Cassandra的语法与SQL非常类似\n\n# 四、Cassandra 系统架构\n\n## 4.1 分布式接口\n- Cassandra 采用P2P分布式架构\n    - 所有节点在结构上是**对等**关系\n- Cassandra任一节点**宕机**\n    - 可能对整个集群的吞吐性能造成潜在的影响\n    - 不会造成灾难性的服务中断\n- Cassandra扩展能力强\n    - 集群扩展时，绝大多数步骤都是自动完成的\n    - 得益于P2P的架构，集群的扩展想必**主从结构更**为便捷\n    - \n## 4.2 不同节点的相互感知 —— 流言协议（Gosspi协议）\n在Hadoop这种主从架构的系统中，所有数据节点定期与主节点通讯。所以主从架构中管理节点比较容易。由于cassandra的P2P架构与主从架构不同，在管理集群节点需要特殊技术，那么P2P架构如何管理节点。\n\n  Cassandra借鉴了Amazon的键值系统Dynamo的体系架构，节点利用Gossip协议来发现集群中其他节点的位置（如路由表、Hash环上的位置）、状态（如版本，负载，死活）等信息\n- 流言协议也被成为”Epidemic Algorithms“（疫情算法）：一个节点一旦获得了另一个节点的信息，它就将信息传给所有节点。\n\n- Gossip交换信息的三种模式\n    - 推模式（Push）\n    - 拽模式（Pull）\n    - 推+拽模式（Push - Pull）\n    - Cassandra Gossip协议选用了第三种模式 \n        - 发起者周期性地随机选择一个节点（朋友节点），并初始化一个与它的gossip会话\n            1. gossip 发起者向朋友节点发送GossipDigestSynMessage\n            2. 这个朋友节点接收到该信息后，返回GossipDigestAckMessage\n            3. 发起者接收到朋友节点的ACK消息后，向朋友节点发送 GossipDigestAck2Message\n\n# 五、一致性哈希与数据切分\n\n- 一致性哈希的基本思想\n    - 用同样的哈希函数来计算数据对象和节点的哈希值\n    - 哈希对象不只是数据，还有节点\n- 节点不再是影响书记对象哈希值的参数，而是作为哈希值的参数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【工业与大数据】NoSql——Cassandra 键值存储系统",
        "date": "2020-02-19 11:28:52",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gong-ye-yu-da-shu-ju-da-shu-ju-de-shu-ju-ge-shi-jian-zhi-cun-chu-xi-tong"
    },
    {
      "content": "-- 1 清空临时表,清空后注意提交\n```sql\ndelete EQP_ALARM_MST_PP_TEMP\n```\n-- 2 用excel生成的代码 插入到临时表\n\n\n-- 3 判断临时表中是否有重复数据\n```sql\nselect count(distinct t.EQP_MODULE_ID ||t.EQP_DCP_ID || t.ALARM_ID) from EQP_ALARM_MST_PP_TEMP t \nselect count(t.EQP_MODULE_ID ||t.EQP_DCP_ID || t.ALARM_ID) from EQP_ALARM_MST_PP_TEMP t\n```\n\n-- 4 如果有重复数据  删除临时数据  提交\n```sql\ndelete from EQP_ALARM_MST_PP_TEMP T\n where (t.EQP_MODULE_ID, t.EQP_DCP_ID, t.ALARM_ID) in\n       (select EQP_MODULE_ID, EQP_DCP_ID, ALARM_ID\n          from EQP_ALARM_MST_PP_TEMP\n         group by EQP_MODULE_ID, EQP_DCP_ID, ALARM_ID\n        having count(*) > 1)\n   and rowid not in (select min(rowid)\n                       from EQP_ALARM_MST_PP_TEMP\n                      group by EQP_MODULE_ID, EQP_DCP_ID, ALARM_ID\n                     having count(*) > 1)\n```\n\n-- 5 将临时数据表merge 到目标表\n\n--方法1\n```sql\nINSERT INTO EQP_ALARM_MST_PP\n  SELECT *\n    FROM EQP_ALARM_MST_PP_TEMP t\n   where not exists (SELECT 1\n            FROM EQP_ALARM_MST_PP\n           where EQP_ALARM_MST_PP.EQP_MODULE_ID = t.EQP_MODULE_ID\n             and EQP_ALARM_MST_PP.EQP_DCP_ID = t.EQP_DCP_ID\n             and EQP_ALARM_MST_PP.ALARM_ID = t.ALARM_ID)\n```\n--方法2\n```sql\nMerge into EQP_ALARM_MST_PP G\nusing (select * from EQP_ALARM_MST_PP_temp) NG\non (G.EQP_MODULE_ID = NG.EQP_MODULE_ID \nand G.EQP_DCP_ID = NG.EQP_DCP_ID \nand G.ALARM_ID = NG.ALARM_ID\n)\nwhen not MATCHED THEN\nINSERT (RAWID,EQP_MODULE_ID,EQP_DCP_ID,ALARM_ID,ALARM_CODE,ALARM_TEXT,ALARM_TYPE,USED_YN,SEVERITY_CD,SEND_YN,FIRST_YN,SUBEQP_RAWID,DESCRIPTION,CREATE_DTTS,CREATE_BY,LAST_UPDATE_DTTS,LAST_UPDATE_BY,EQP_ID,SOURCE_ID)\nVALUES (NG.RAWID,NG.EQP_MODULE_ID,NG.EQP_DCP_ID,NG.ALARM_ID,NG.ALARM_CODE,NG.ALARM_TEXT,NG.ALARM_TYPE,NG.USED_YN,NG.SEVERITY_CD,NG.SEND_YN,NG.FIRST_YN,NG.SUBEQP_RAWID,NG.DESCRIPTION,NG.CREATE_DTTS,NG.CREATE_BY,NG.LAST_UPDATE_DTTS,NG.LAST_UPDATE_BY,NG.EQP_ID,NG.SOURCE_ID)\n```",
      "data": {
        "title": "【代码仓库】SQL -- 数据批量插入",
        "date": "2020-02-14 11:37:01",
        "tags": [
          "SQL",
          "代码仓库"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/sqlinsert.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "sqlinsert"
    },
    {
      "content": "MapReduce作为大数据技术最主流的并行计算方案，仍然存在编程实现较为复杂（麻烦但不难），性能较差的问题。MapReduce在运算过程中会产生大量的IO操作。为了提高性能，我们引入内存计算的概念。\n<!-- more -->\n\n# 一、背景\n\n### 1.1 并行计算中的局部性\n\n![](http://doc.xr1228.com//post-images/1581930013675.PNG)\n\n矩阵计算过程中，大量的Catch失效消耗了大量的时间，为了解决这个问题，人们提出了分块运算的思想，我们后面进行详细介绍。\n\n### 1.2 高可用性\n- 大数据处理系统通常是由大量不可靠的的服务器组成的的\n- 传统的容错方法不适用\n    - 锁步法，多版本编程\n- 检查点设置与恢复\n\n\n# 二、内存计算技术的必要性\n大数据处理并行系统，最主要就是对以下三个方面进行权衡\n\n- 编程模型 ： 如何识别和描述并行程序\n- 性能/成本优化\n- 容错能力\n\n虽然MapReduce的发明与实现为开创了大数据的新时代，它很好的解决了自动容错，自动负载均衡，并行化处理的问题，但是随着用户对系统提出了更高的要求时，引入过多I/O操作的MapReduce很难支持复杂的，实时的交互式查询。\n\n所以说MapReduce的瓶颈在于大量的IO操作，这些操作产生的大量数据都需要存储在HDFS中。那么如果我们将MapReduce的中间结果存储在内存中，是否就能大幅度提升MapReduce的效率呢？答案是肯定的，这样的方案比之前速度提升10-100倍！\n![](http://doc.xr1228.com//post-images/1582015787498.PNG)\n\n> Distributed memory ：分布式内存\n\n# 三、内存计算的可行性\n\n- 内存是否足够大能够装下所需的数据？   → 现在单台机器数TB RAM的服务器已经很常见\n- 内存有多贵？与硬盘想必性价比如何？  → 摩尔定理\n- 数据保存在硬盘上，可以保证数据的可用性，放在内存里如果容错？\n- 如果高效表示内存里的数据？\n\n![](http://doc.xr1228.com//post-images/1582016119131.PNG)\n\n\n各个内存层次的延迟：DRAM比硬盘块100000倍，但DRAM还是比cache慢6-200\n\n![](http://doc.xr1228.com//post-images/1582016314700.PNG)\n\n> Tape is Dead，Disk is Tape，Flash is Disk，RAM Loacality is king —— Jim Gray \n\n# 四、 SPARK的设计理念\n\n传统抽象多台机器的内存的方案\n- 分布式共享内存（DSM）\n    - 统一地址空间\n    - 很难容错\n- 分布式键-值存储（Piccolo，RAMCloud）\n    - 允许细粒度访问\n    - 可以修改数据（MUTABLE)\n    - 容错开销大\n\nDSM和键值对的容错机制\n- 副本或Log\n    - 对数据密集应用来说开销很大\n    - 比内存写要慢10-100倍\n  \n\n  ## 4.1 内存处理设计方案\n\n  - RDD （Resilient Distributed Datasets）\n    - 基于数据集合，而不是单个数据\n    - 由确定性的粗粒度操作产生（map，filter，join等）\n    - 数据一旦产生，就不能修改（immutable）\n    - 如果要修改数据，要通过数据集的变换来产生新的数据集\n    - 高容错性：数据一旦是确定性的产生，并且产生后不会变换\n        - 就可以通过”重复计算“的方法来恢复数据\n        - 只要记住rdd的生成过程就可以了，这样一次log可以用于很多数据，在不出错的时候几乎没有开销\n```Scala\nmessage = textFile(...).filter(_.contains(\"error)).map(_.split('\\t')(2))\n```\n\n\n![](http://doc.xr1228.com//post-images/1582017712946.PNG)\n\n\n# 五、Spark编程技术\n\n- 基于Scala\n    - 类似Java的一种函数语言\n    - 可以在Scala控制台上交互式的使用Spark\n    - 现在也支持Java和Python\n- 基于RDD的操作\n    - Transformation：从现有RDD产生新的RDD\n        - map，reduce，filter，groupBy，sort，distinct，sample ……\n    - Action：从RDD返回一个值\n        - count，collect，first，foreach\n\n### 例子：Log挖掘\n将数据空文件系统中调入内存，然后进行交互式的查询\n```JAVA\nlines = spark.textFile(\"hdfs://...\")\nerror = lines.filter(_startwith(\"error\"))\nmessages = errors.map(_.split('\\t)(2))\ncachedMsgs = messages.cache()  //将其存入缓存\ncachedMsgs.filter(_.contains(\"foo)).count\ncachedMsgs.filter(_.contains(\"bar\")).count\n```\n性能  1TB数据在内存上需要5-7s完成，在硬盘上需要 170s\n\n### 例子：逻辑回归\n```JAVA\nval data = spark.textFile(...).map(readPoint).cache()\nvar w = Vector.random(D)\nfor(i <- 1 to ITERATIONS){\n    var gradient = data.map(p => (1/(1+exp(-p.y*(w dot  p.x))) - 1)*p.y*p.x)\n    .reduce( _ + _ )\n    w -= gradient\n}\nprintln(\"final w: ' +w）\n```\n\n![](http://doc.xr1228.com//post-images/1582018554068.PNG)\n\n### 例子：WorkCount\n\n```JAVA\nvar spark = new SparkContext(master,appName,[sparkHome],[jars])\nvar file = spark.textFile(\"hdfs://...\")\nvar counts = file.flatMap(line -> line.split(\" \"))\n                    .map(word => (word,1))\n                    .reduceByKey( _ + _ )\ncounts.saveAsTextFile(\"hdfs://,,,\"）\n```\n\n- SparkContext 实例化一个spark\n- flatMap 将某一个字段分为多个元素\n    - line = “a b c a” →  （a）（b）（c）（a） → （a，1）（b，1）（c，1）（a，1）\n- reduceByKey → （a，1）（b，1）（c，1）（a，1） → （a，2）（b，1）（c，1）\n  \n\n  # 六、Spark的实现\n\n### 6.1 延迟估值（Lazy Evaluation）\n\n  \n```JAVA\nvar lines = sc.textFile(\"data.txt\")\nval lineLengths = lines.map(s => s.length)\nval totalLength = lineLengths.reduce((a,b) => a + b)\n```\n前两行都不会出发计算（Transformation）\n最后一行的reduce会引发计算，生成DAG\n\n- 复杂的DAG（Directed acyclic grap 有向无环图）\n![](http://doc.xr1228.com//post-images/1582074271042.PNG)\n\n### 6.2 Spark性能优化\n\n#### 6.2.1 数据划分技术\nspark通过数据划分将 links 与\n```java\nlinks = // RDD of (url,neighbors) pairs    url和相邻的网页\nranks = // RDD of (url,rank) pairs   网页的rank\n\n// 通过不断循环，实现配置rank算法\nfor(i <- 1 to ITERATIONS){\n    ranks = links.join(ranks).flatMap{\n        (url,(links,rank)) => links.map(dest => (dest,rank/links.size))\n    }.reduceByKey(_ + _)\n}\n```\n![](http://doc.xr1228.com//post-images/1582074683069.PNG)\n![](http://doc.xr1228.com//post-images/1582074807555.PNG)\n\n#### 6.2.2 Cache\n\n- 对messages使用cache，意思是将后面可能会重用的数据保存起来，并“尽量”放在内存中\n    - 正常计算的时候避免重算\n    - Cache是Persist的特例,是RDD提供的将数据保存在内存的方法\n```java\nlines = spark.textFile(\"hdfs://...\")\nerrors = lines.filter(_startsWith(\"ERROR\"))\nmessages = errors.map(_split('\\t')(2))\ncachedMsgs = messages.cache()\ncachedMsgs.filter(_.contains(\"bar\")).count\n```\nStorageLevel列表\n![](http://doc.xr1228.com//post-images/1582081342943.PNG)\n\n- MEMORY_ONLY 2 表示数据保存两份数据\n\n\n# 七、Spark的生态环境\n![](http://doc.xr1228.com//post-images/1582081795189.PNG)\n\n- Spark 是伯克利大学AMP实验室开发的大数据系统\n- Mesos ： 底层资源管理系统和调度器\n- HDFS ： Hadoop 文件管理系统\n- Tachyon ： 内存文件系统\n- Spark ： 内存计算框架\n- Shark ： Spark支持SQL API\n- Spark Streaming ： Spark支持流计算\n- GraphX ： Spark 支持图算法与模型\n- MLbase ： Spark 支持机器学习\n\n\n现在的大数据系统，MapReduce是通用的批处理系统，而其他的工具用于实现专门业务的专用系统，例如Pregel，Giraph，Dremel，Drill，Tez，Impala，GraphLab，Strom，S4。而Spark系统希望将MapReduce一般化（任务DAG和数据共享）并统一编程框架。\n然而Spark仍有局限性，Spark进行例如BFS（图遍历）算法过程中每次进行细粒度更新时，无法对RDD内部进行编辑，需要更换新的RDD。从而发生大量无用的内存拷贝，也产生了大量无用数据，导致性能的问题。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【工业与大数据】内存计算的解决方案 —— Spark",
        "date": "2020-02-10 09:03:05",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/gong-ye-yu-da-shu-ju-nei-cun-ji-suan-geng-kuai.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "MapReduce作为大数据技术最主流的并行计算方案，仍然存在编程实现较为复杂（麻烦但不难），性能较差的问题。MapReduce在运算过程中会产生大量的IO操作。为了提高性能，我们引入内存计算的概念。",
      "fileName": "gong-ye-yu-da-shu-ju-nei-cun-ji-suan-geng-kuai"
    },
    {
      "content": "大数据作为一门应用广泛的技术，在不同的应用场景下对其数据结构，处理实时性都有不同的需求，所以大数据技术的先驱们开发了许多不同的技术框架来满足不同的需求。本章主要介绍大数据所采用的的主流处理框架以及其技术细节。\n<!-- more -->\n\n\n- 大数据处理工具分类\n  ![](http://doc.xr1228.com//post-images/1581042442307.PNG)\n\n\n# 一、几个重要的概念\n\n### 大数据技术的几个重要的观点，这个也是贯穿在整个大数据技术的重要思想\n\n- 分布式：数据存储于成百上千个服务器中\n- 大数据块：大数据块减少元数据的开销\n- 失败无法避免：使用商用硬件 → 失败是不可避免的，所以买便宜的硬件\n- 简洁的才是稳定的：简洁的一致性模型（单写者，避免相互等待）\n\n\n### 数据并行化（DLP）\n- 若干硬盘上的大量数据，可以被并行化的操作（比如，操作文档） Embarrassingly Parallel\n\n这是什么意思呢？将数据分隔成不同的，相互无关的数据块就能实现数据并行化。我们举个例子：\n\n**词频统计**   从多个数据中找到dog的发生次数，我们只需要把数据分成不同的块，同时进行查找，没找到一个dog，就返回一次结果。这样就能显著提高查找效率，这也是一种很朴实的观点。\n\n![](http://doc.xr1228.com//post-images/1581043388967.PNG)\n\n但是这样的解决方案也衍生了两个问题：\n- 共享的状态\n    - 吞吐量（多个进程同时改变）\n    - 同步（同时修改需要锁）\n- 小粒度的通信让元数据管理变得复杂\n\n为了解决这样的问题，我们将每个数据块看做一个单元，每个单元全部数完后将结果一次性返回。\n看似很美好，但是又又又衍生出两个问题：\n\n- 失败的机器（某个机器发生错误无法及时发现异常）\n- 共享的状态太大（返回的数据量太大）\n\n所以我们将全局状态也作为分布式状态，并且将每个数据块的存储状态保存下来。这样就满足了分布式处理的需求。\n![](http://doc.xr1228.com//post-images/1581059591932.PNG)\n\n> 以上提到的设计理念，就是MapReduce的设计理念。接下来我将对MapReduce进行详细介绍。\n\n# 二、MapReduce\n\n### MapReduce Process —— 数据并行的分治策略\n- Map\n    - 将数据分割为shards或者splites，将它们分配给工作节点，将工作节点来计算子问题的解。\n- Reduce\n    - 收集，合并子问题的解\n- 易于使用\n    - 开发者可以集中解决数据处理的问题\n    - MapReduce系统负责解决其他细节\n  \n  > MapReduce是很早就提出的想法，是算法设计中常用的策略。但是其技术特点非常符合大数据的技术需求，很好的解决了大数据系统的需求，让开发者集中精力进行数据处理，而不用考虑数据内部的细节。\n\n  ### MapReduce 的基本编程模型\n\n- Map\n    - map（in_key，in_value） → list（out_key,intermediate value)\n        - 处理输入的键值对\n        - 生成中间结果集\n- Reduce\n    - reduce(out_key,list(intermediate_value)) → list(out_value)\n        - 对于某个键，合并他所有的值\n        - 生成合并后的结果值集合 \n\n例子： 词频统计\n\n![](http://doc.xr1228.com//post-images/1581060446962.PNG)\n\nMapReduce算法的程序实现是非常简洁的\n\n```C\nmap(String input_key,String input_value):\n    //input_key:document name\n    //input_value:document contents\n    local Count = CountLocally(input_value);\n    foreach count:\n        Emit(word,count); //Produce count of words\n\nreduce(String word,Iterator intermediate_values):\n    //word:the word(in the intermediate key);\n    //intermediate_value:a list of counts;\n    int result = 0;\n    for each v in intermediate_values;\n        result += v;\n    Emit(word,result);\n```\n\n![](http://doc.xr1228.com//post-images/1581060926629.PNG)\n\n### MapReduce 的执行步骤\n\n1. 将输入数据分隔成M块，在每块上分布式的调用map()\n    - 通常每个数据魁岸16MB或者64MB\n    - 取决于GFS的数据库大小\n2. 输入数据由不同的服务器并行处理\n3. 通过将中间结果分割成R块,对每块分布式的调用Reduce()\n\n- M和R的数量由用户指定\n    - M>>#servers,R>#servers\n    - 很大的M值有助于负载均衡,以及快速恢复\n    - 每个Reduce()调用,对应一个单独的输出文件,若依R值不应该太大\n\n![](http://doc.xr1228.com//post-images/1581061621076.PNG)\n\n![](http://doc.xr1228.com//post-images/1581061663957.PNG)\n\n\n### Map Recude的性能优化\n\n- MapReduce 冗余执行\n    - 整个任务完成时间是由最慢的节点决定的\n    - 解决方案:在接近结束时,生成冗余任务 → 用其他机器同样进行冗余任务\n        - 谁最先完成,谁获胜\n        - 也叫做\"投机\"(speculative)执行\n    - 影响:极大的缩短任务完成时间\n        - 资源消耗增加 3%,大型任务速度提高 30%\n\n> MapReduce所有的操作都是独立且幂等的,所以不存在同步性问题\n\n- MapReduce故障处理\n    - 计算节点故障\n        - 控制节点通过周期性的心跳来检测故障\n        - 重新执行\n    - 主节点故障\n        - 可以解决,但是目前还没有解决(控制节点故障可能性很低,所以就直接重启即可)\n    - 健壮性\n        - MapReduce论文报告:曾经丢失1800个节点中的1600个,但是任务仍然正确完成.\n\n## Hadoop ：MapReduce的开源实现\n\n### Hadoop MapReduce的基本架构\n\n> Hadoop不仅仅实现了文件分布式存储和MapReduce，还实现了一系列容错、资源远离等服务\n\n- JobTracker（Master）\n    - 接收MR作业\n    - 分配任务给Worker\n    - 监控任务\n    - 处理错误\n- TaskTracker（worker）\n    - 运行Map和Reduce任务\n    - 管理中间输出\n- Client\n    - 提交作业的界面\n    - 得到多样的状态信息\n- Task\n    - 一个独立的过程\n    - 运行Map/Reduce函数\n\n\n### Hadoop MR程序执行过程 1\n\n![](http://doc.xr1228.com//post-images/1581090883921.png)\n\n![](http://doc.xr1228.com//post-images/1581093484533.png)\n\n\n![](http://doc.xr1228.com//post-images/1581093664775.png)\n\n\n## MapReduce总结\n\n### MapReduce的理解要点\n- 同样的细粒度操作（Map&Reduce）重复作用于大数据\n- 操作必须是确定性的\n- 操作必须是幂等的，才没有副作用\n- 只有shuffle过程中才有通信\n- 操作（Map&Reduce）的输出存储于硬盘上\n\n### MapReduce的作用\n- Google\n    - 为Google Search建立索引\n    - 为Google News进行文章聚类\n    - 统计行的机器翻译\n- Yahoo！\n    - 为Yahoo！Search建立索引\n    - 为Yahoo！Mail进行垃圾检测\n- Facebook\n    - 数据挖掘\n    - 广告优化\n    - 垃圾检测\n\n### MapReduce优点\n- 分布式过程完全有名\n    - 没有一行分布式编程（方便，有保证正确性）\n- 自动的容错性\n    - 操作的确定性保证了故障的任务可以在其他地方再次运行\n    - 保存的中间结果保证了只需要重新运行故障reduce节点\n- 自动的规模缩放\n    - 由于操作是没有f副作用的，所以他可以动态的被分发到任何数量的机器\n- 自动的负载均衡\n    - 及时移动任务，投机性的执行慢的任务\n  ### MapReduce缺点\n  1. 及其严格的数据流\n  2. 很多常见的操作也必须手写代码\n  3. 程序语义隐藏在map-reduce函数中：自动的维护，扩展，优化都比较困难\n\n\n# 三、PIG LATIN 编程语言\n\n> PIG LATIN本意是英语中一种“黑话”的规则，其规则就是将单词首字母放置在最后并加上ey，比如“happy” ➡️ “appy-hey” \n\n在大数据技术中，PIG LATIN是一种高于MapReduce的可以处理任意数据流的大数据处理系统（也是一种语言）。\n\n为了说明PIG LATIN的作用，我们可以举个例子\n\n![](http://doc.xr1228.com//post-images/1581146546078.png)\n\n为了解决这个需求，传统的SQL 需要将两个表 Join在一起，再通过Group by，count的方式进行查询。但是显而易见，在互联网中这两个表可能是非常非常非常大的，他们只能被分布式的存储在不同的机器中，那么如何进行查询和运算呢？\n\n![](http://doc.xr1228.com//post-images/1581146799512.png)\n\n如果通过MapReduce进行运算，则需要将不同的MapReduce结合起来多次运算，最主要的MapReduce需要参数具有相同的数据类型，我们可能还涉及到数据类型的转换，这样就产生了大量的代码，也很难进行维护\n\n![](http://doc.xr1228.com//post-images/1581146968591.png)\n\n因此，Yahoo！发明了PIG LATIN语言。\n\n- 更高级的编程语言\n    - 更快捷的MapReduce工作流程\n    - 提供关系型数据库操作（例如JOIN，GROUP BY）\n    - 可以方便地潜入JAVA函数\n- 最先在Yahoo！Research使用\n    - 当是运行Yahoo！大约50%的任务\n\n## 3.1 PIG LATIN的基本语法\n\n```PIG LATIN\nvisits = load '/data/visits' as (user,url,time);\ngVisits = group visits by url;\nvistCounts = foreach gVisits generate url,count(visits);\n\nurlInfo = load '.data.urlInfo' as (rul,categroy,pRank);\nvisitCount = join visitCounts by url,urlInfo by url ;\n\ngCategories = group visitCounts by category;\ntopUrls = foreach gCategories generate top(vistCounts,10);\n\nsotre topUrls into 'data/topUrls';\n```\n\n嵌套的数据结构\n\n- Pig Latin采用完全可以嵌套的数据结构\n    - 原子值（Atomic Values），元组（tuples），包（列表，bages（lists）），映射（maps）\n\n![](http://doc.xr1228.com//post-images/1581148734773.png)\n\n- 优势\n    - 对于开发者，比数据库的扁平组（flat tuple）更自然\n    - 避免代价昂贵joins操作\n\n- 嵌套数据模型\n    - 解耦grouping操作作为一个独立的操作\n  ![](http://doc.xr1228.com//post-images/1581148988714.png)\n    - 共同分组（CoGroup） 性能优化\n  ![](http://doc.xr1228.com//post-images/1581149076178.png)\n\n## 3.2 Pig Latin的实现与优化\n\n User ➡️ PIG（或者写SQL）➡️Hadoop Map-Reduce ➡️cluster\n\n Pig Latin 翻译为 Map-reduce的方法\n- 每一个group或join操作形成一个MapReduce\n- 其他操作进入map和reduce阶段的流水线\n\n![](http://doc.xr1228.com//post-images/1581149506733.png)\n\n- 抽象的优势\n    - 抽象的程序更简单，计算机可以进行优化\n    - 可以逐渐优化，不影响用户使用\n![](http://doc.xr1228.com//post-images/1581149584250.png)\n\n- Pig Latin的优化\n    - 合并函数（combiner）\n        - 中间过程传递数据越少越好，聚合求和运算越早执行越好\n        - 聚合函数\n        - 去掉重复数据（distinct）\n        ![](http://doc.xr1228.com//post-images/1581149915655.png)\n    - 偏斜数据的链接（Skew Join）\n        - 如果很多值都有同样的健，就会有问题\n        - Skew join对数据进行采样，来找到高频值\n        - 在reducer中进一步分割这些数据\n        - 转化为map-oinly的任务\n            - 将很小的数据集作为旁路输入（“sid file”）\n    - 多数据流：PIG通过split将Map分为多个数据流，减少Reduce操作\n\n# 四、其他类似框架\n\n- Sawzall\n    - 基于MapReduce的数据处理语言\n    - 严格的结构：过滤➡️聚合\n- Hive\n    - 基于MapReduce的类似SQL的语言\n- DryadLINQ\n    - 基于Dryad的类似SQL的语言\n\n# 五、总结\n\n- Hadoop与PIG\n![](http://doc.xr1228.com//post-images/1581150296782.png)\n- Hadoop 生态系统\n![](http://doc.xr1228.com//post-images/1581150412879.png)\n\n- 另一面：“MapReduce： A major step backwards”\n    - David J.DeWitt,Michael Stonebraker\n    - 在编程模式中后退了一大步\n        - 没有模式，没有高级的访问语言\n    - 一个次优化的实现\n        - 它使用了暴力法搜索，而不是用任何索引\n    - 一点也不创新\n        - 25年前就有类似的技术\n    - 缺少了目前数据库管理系统一般都有的大多数特点\n        - 索引，更新，食物，完整性约束，逻辑视图\n<!-- more -->\n",
      "data": {
        "title": "【工业与大数据】大数据的主要处理框架与工具",
        "date": "2020-02-07 10:18:09",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/gong-ye-yu-da-shu-ju-da-shu-ju-de-zhu-yao-chu-li-kuang-jia-yu-gong-ju.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "大数据作为一门应用广泛的技术，在不同的应用场景下对其数据结构，处理实时性都有不同的需求，所以大数据技术的先驱们开发了许多不同的技术框架来满足不同的需求。本章主要介绍大数据所采用的的主流处理框架以及其技术细节。",
      "fileName": "gong-ye-yu-da-shu-ju-da-shu-ju-de-zhu-yao-chu-li-kuang-jia-yu-gong-ju"
    },
    {
      "content": "为什么传统的NFS/AFS并不能满足大数据的需要？为什么GFS大名鼎鼎？它解决了什么样的问题？\n<!-- more -->\n# 一、Google文件系统\n\n- 为什么需要一个不同的分布式文件系统？\n    - 为了建立搜索引擎，需要存储互联网容量的数据，支持数据快速写入到分布式文件系统中\n    - 为了支持查询，需要对大量数据进行处理，需要建立**倒排索引**，需要对网页数据进行排序\n    - 所有的技术革新，都是业务驱动的，业务需求决定了Google 文件系统的开发\n\n- GFS中的具体需求\n    - 需要一个分布式文件系统能够存储大量的数据\n        - 这样的文件系统建立在大规模X86集群之上，这些节点是廉价的，并且系统的模块还会出错\n    - 现有的文件系统无法满足Google对于存储数据的需求\n        - 整个硬件中的许多模块会出现出错的情况，出错会同时发生\n        - 有大量的超大规模文件（多个网页合并成的大数据文件），文件大小会超过数百G\n    - 读写模式（优化考虑）：\n        - 文件系统读写大量是写入一次，多次读取的特性\n        - 写入并发，并发读取\n        - 延迟和带宽的考虑（高延迟，高带宽）\n\n# 二、如何设计Google文件操作系统\n\n- 几个目标\n    - 要做一个文件系统（目录树，文件读写），支持读写非常大的文件\n    - 充分利用资源（负载均衡，扩展性）\n    - 容错（不能因为少数的节点出错就停止工作）\n    - 系统简洁（复杂的系统在涉及到数千个节点的时候无法理解与控制）\n\n\n为了实现以上目标，Google给出了文件系统设计的基本设计：\n- 文件系统的基本设计\n    - 数据块：由于文件的规模十分庞大，文件将会被划分为多个大小为64MB的数据块进行存储，这个数据块的大小远远大于一般文件系统数据块的大小（64K）\n    - 性能设计：依据全局动态信息，自动调整数据在不同服务器中的存放，服务器存储利用率相似，负载动态调整\n    - 可靠性：为了保证数据的可靠性，数据通过副本的方式保存在多个节点中，一般保存在3个节点以上\n    - 系统设计简化：通过单个节点保存文件系统的元数据，这个节点被称为Master节点，主借点来协调整个系统的访问流程。\n\n\n# 三、分布式文件系统的设计\n![](http://doc.xr1228.com//post-images/1580957028720.PNG)\n\n- 文件系统的主节点（存储元数据）\n- 文件系统命名空间：将文件路径与chunk对应信息保存（chunkServer） \n- 应用程序发送请求后，Master节点返回chunkhandle，chunklocations的信息，应用程序根据以上信息访问对应服务器。\n\n# 四、GFS性能问题\n\n根据之前的设计，我们很明容易就能发现这样的文件系统可能会存在两个问题：\n- 所有的访问都会通过Master节点，可能会成为性能瓶颈\n- master节点发生异常后整个文件系统都会出现异常\n\n为解决以上问题：\n- 主服务器的性能负载问题（主要的问题）\n    - 客户端数据缓存，每次请求获取1000chunk的元数据，减少客户端与元数据信息交互\n    - 元数据服务器存储在内存中\n- 块服务器的负载均衡问题 \n    - 不能让一部分块服务器出现性能瓶颈 （chunkServer）\n    - 负载必须要进行动态调整\n- 块服务器的扩展性问题\n\n> 在GFS中，一个64M的数据块大约需要64B元数据。10PB数据约需要 10GB的元数据控件（很容易可以满足）\n\n# 五、GFS可靠性问题\n\n- 块服务器的可靠性问题\n    - 快服务器出现错误怎么办？ → master服务器发现块服务器不在线时，启动副本恢复\n    - 一个块服务器出现错误的时候，副本数目恢复所需要的时间 （不同的数据块从不同服务器并行恢复）\n- 主服务器的可靠性问题\n    - 内存数据的可恢复性（日志操作，快速恢复，定期硬盘快照）\n    - 单个节点主服务器的可恢复性 → 影子（shadow）服务器\n    - 影子节点仍然会出现错误 → 硬盘快照保存多个副本\n\n# 六、 GFS一致性要求\n- 三副本一致性的基本要求\n    - 目标：维持每一个数据块的三个副本完全一样\n    - 方法：出事数据块都没有数据，出事数据相同，之后以相同的操作顺序执行客户端的操作\n    - 手段：基于租期以及主要副本的顺序定义\n\n![](http://doc.xr1228.com//post-images/1580972371396.PNG)\n\n- GFS中写入操作对一致性的影响\n\n![](http://doc.xr1228.com//post-images/1580972774298.PNG)\n\n- GFS 放松的一致性\n    - 一致的（Consistent）：文件的三个副本一直\n    - 明确的（Defined）：反映了客户端的操作\n\n\n# 七、GFS的POSIX兼容性\n\n> GFS不是标准的文件系统，是建立在本地文件系统之上的应用层文件系统。GFS与标准的POSIX文件系统并不兼容，因此GFS上不能够运行程序，访问GFS需要一个客户端。\n\n- 在数据的读写上，GFS的POSIX不一致主要表现在以下两个方面：\n    - 数据读写： GFS增加了Append操作，由文件系统确定写入地址，这是POSIX所没有的\n    - 数据一致性：POSIX不兼容，GFS定义了自己的数据一致性模型\n\n> 兼容性哲学：通用的一般不是最优的策略\n\n# 八、GFS的垃圾收集\n\n- 垃圾收集\n    - 删除的数据不是直接从本地文件系统中删除，而是通过垃圾收集的方法，比传统的方法简单，并更加可靠\n    - 主服务器要日志记录删除操作，并将文件改名成隐藏的文件名\n    - 在系统负载不高的时候后台挥手隐藏的文件\n- 过期副本的删除\n    - 整个系统在节点失效，并重新加入的时候产生过期副本数据\n    - 通过检查数据库的版本来探测到过期副本\n\n# 总结\n\nGFS实际上是演示了如何在现代市场上可见的硬件水平上构建一个大规模的处理系统\n- 从设计上就内建错误容忍机制\n- 对大文件的优化，特别是数据追加以及读取\n- 不局限于现有的文件系统接口，为了应用进行接口的扩张\n- 尽量使用简化的设计，如单个主服务器single master，简化系统的结构，便于理解与维护\n  \n  GFS以及相关的开源等价软件包括HDFS，MooseFS等限制的部署都非常广泛，验证了这个结构的有效性。",
      "data": {
        "title": "【工业与大数据】GFS：Google文件系统",
        "date": "2020-02-06 10:26:12",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/gong-ye-yu-da-shu-ju-gfsgoogle-wen-jian-xi-tong.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "为什么传统的NFS/AFS并不能满足大数据的需要？为什么GFS大名鼎鼎？它解决了什么样的问题？",
      "fileName": "gong-ye-yu-da-shu-ju-gfsgoogle-wen-jian-xi-tong"
    },
    {
      "content": "## 一、文件系统基础  \n</br>\n\n### 文件系统概述\n#### 为什么要有文件系统？\n需要介质保存一些永久的数据，停电后数据也可以长期保存\n#### 文件系统的名字空间，名字空间的操作\n在文件数节点上进行操作\n#### 文件系统中文件读写操作\n提供一些例如 open、read、write、close的操作函数\n- open 操作：将文件 offset = 0，并记录文件操作信息\n- close 操作：将文件从内存中删除\n- read 操作：从offset=0位置读取size大小的数据。\n  \n### 文件系统的设计\n#### 文件系统的下层接口\n- 磁盘的读写接口，磁盘中的地址\n#### 文件系统的上层接口\n- 文件树的组织\n- 文件数据的读写\n#### 文件系统最本质的功能：将文件名字翻译定位到一个具体的磁盘位置，进而可以完成文件的读写。  \n\n</br>\n\n\n### 文件系统接口标准化\n虚拟文件系统（VFS）是物理文件系统与服务之间的一个接口层，它对Linux的每一个文件系统的所有细节进行抽象，使得不同的文件系统在Linux核心以及系统中运行的其他进程看来，都是相同的。即调用VFS接口来调用不同的文件操作系统。\n</br>\n</br>\n### 文件系统的磁盘数据结构\n![](http://doc.xr1228.com//post-images/1580632535964.png)\n\n### 文件系统的讨论\n- 关于磁盘块大小的讨论\n    - 一个文件起码占用1个文件块的空间（选择磁盘块越小浪费越小）\n    - 每个磁盘块需要元数据进行描述（磁盘块越多，开销越大）\n    - 虽然磁盘物理特性决定了最小的读写单元512字节，但是目前多数文件系统选用4k磁盘块。（根据不同文件系统特点选择）\n\n- 文件系统的缓存\n    - 缓存能够加速的必要条件，时间局部性（经常访问）与空间局部性（附近的数据也需要访问）\n\n- 磁盘系统的优化策略\n    - 磁盘的顺序读写与随机读写：尽量让磁盘进行顺序读写（顺序读写100MB带宽，随机读写1MB带宽）\n    - 如何进行磁盘优化\n\n## 二、分布式文件系统\n\n- 分布式文件系统需要提供什么功能？\n    - 文件系统目录树\n    - 文件的读写\n- 分布式文件系统建立的基础要讨论的两个问题\n    - 是否直接面对磁盘？ \n        - 无需直接面对磁盘，而是使用每台机器的操作系统中的文件系统来操作磁盘\n        -  直接面对磁盘： SANFS 更高性能\n    - 分布式文件系统中的地址是什么？\n        - 无法直接定位到磁盘：先定位到机器，然后定位到磁盘\n\n> 分布式文件系统的本质功能：将一个以目录树表达的文件翻译为具体的节点，而到磁盘的定位则可以交给本地文件系统完成。\n\n## 三、分布式文件系统举例 NFS（网络文件系统）\n\n![](http://doc.xr1228.com//post-images/1580954964552.PNG)\n\n###NFS文件系统的扩展：AFS文件系统\nNFS系统只有一台服务器，通过一台服务器对文件进行定位，用户操作某一个文件时，其实是对Server上某个目录进行操作。\n\n![](http://doc.xr1228.com//post-images/1580955318970.PNG)\n\nAFS是放在广域网的分布式文件系统\n\n1. 当用户访问某个文件时，先访问根服务器 /afs\n2. 根服务器维护了下一级服务器 （pku,tsinghua,washington)\n3. 每一级服务器为用户返回下一级服务器地址\n4. 最后一步交给本地文件系统对具体文件操作\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【工业与大数据】分布式文件系统",
        "date": "2020-02-02 16:14:41",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/gong-ye-yu-da-shu-ju-fen-bu-shi-wen-jian-xi-tong.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gong-ye-yu-da-shu-ju-fen-bu-shi-wen-jian-xi-tong"
    },
    {
      "content": "### 云计算 Cloud Computing\n既指作为服务通过互联网提供的应用程序（SaaS模式），又指提供这些服务的，位于数据中心的硬件和系统软件（公用计算）\n- 云：数据中心硬件与软件\n- 公有云：用即用即付的模式，开放给大众实用的云\n- 私有云：一个企业或者组织内部的数据中心\n- 公用（utility）计算：给人以无限资源的错觉\n  \n（以上定义来自加州大学伯克利分校，RAD实验室，2009年2月）\n\n### 云计算商业模式的三大特点：\n- 按需服务\n- 资源池\n- 可测量的服务\n\n### 云计算发展的市场条件\n- 大规模的互联网应用（社交网络、多媒体）\n    - 规模经济\n    - 需求增长促进数据中心建设增长\n    - 无法预测的应用增长速度Zynga，Netflix\n- 大数据应用\n    - 日志分析\n    - 机器学习应用\n\n### 云计算的价值 ：提高数据资源利用率\n  \n![](http://doc.xr1228.com//post-images/1580138871978.png)\n![](http://doc.xr1228.com//post-images/1580138914955.png)\n\n### 云计算的分类\n根据提供抽象接口位于哪一层来分类\n- 指令集虚拟机（Amazon EC2，3Tera）\n- 运行时系统虚拟机（Microsoft Azure）\n- 框架型虚拟机（Google AppEngine，Force.com)\n- 折衷：灵活性/可移植性 VS “内置”功能\n  \n  ![](http://doc.xr1228.com//post-images/1580139074150.png)\n\n根据提供服务类型分类\n- SaaS 软件即服务 ——消费者使用提供商运行在云设施上的应用程序，基本无法控制程序或者基础架构。\n- PasS 平台即服务 ——消费者将自己编写的程序部署在云基础设施上，可以控制应用程序，但不能控制基础设施\n- IaaS 基础设施即服务 —— 提供处理、存储、网络和其他基础计算资源，消费者可以利用这些资源部署任意程序，包括操作系统或应用程序。\n\nGartner新技术炒作曲线\n\n![](http://doc.xr1228.com//post-images/1580139452341.png)\n",
      "data": {
        "title": "【工业与大数据】云计算的商业模式",
        "date": "2020-01-27 23:10:56",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/yun-ji-suan-de-shang-ye-mo-shi.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "yun-ji-suan-de-shang-ye-mo-shi"
    },
    {
      "content": "\n大数据这个词已经火热了很多年，似乎处处都存在着大数据的噱头，让我们回归本质，探讨一下大数据是什么？\n本文介绍了大数据技术细节以及相关背景的的一些概念。本文并未对大数据的相关知识进行总结，所以本文仅作为参考，无需详细阅读。\n<!-- more -->\n\n\n\n## 背景 为什么需要大数据？\n\n- 我们比以往产生**更多**且**更多样性**的数据\n- 我们比以往**更快的**产生数据\n- 这些数据具有其价值性\n\n针对以上三个基本原因，我们必须通过处理这些数据来提取其中的价值。\n\n然而处理这些大量的数据面临两个问题：\n\n- 大规模数据的存储\n- 大规模数据的分析\n\n这里我们举一个**例子**：早期的网络环境就如同一条小河，依河而居的人们世代通过抓鱼维生。这个时期鱼的数量有限、种类单一。人们只需要把鱼抓起来放到冰箱，想吃的时候直接拿出来烤就可以了。\n\n![](http://doc.xr1228.com//post-images/1579677299293.PNG)\n\n随着人类抓鱼的速度越来越快，抓鱼水平越来越高。人们抓到的鱼数量越来越大，种类越来越丰富。人们逐渐遇到了两个代表性的问题：\n\n- 冰箱放不下（存储不足）\n- 烹饪不过来（处理效率不足）\n\n如何解决这样的问题呢？\n\n1. 冰箱放不下：\n\n解决冰箱放不下无非两个思路。①换一个大一点的冰箱（**纵向扩展**）②多买几个冰箱（横向扩展）\n显然纵向扩展是难以实现的，存10000...条鱼需要多大的冰箱？\n横向扩展相对容易实现，鱼多的时候多买一些冰箱，搞一个冷库（**集群**）然后大家一起去存放鱼（**分布式存储**）\n然而随着冰箱越来越多（**集群规模扩大**），人们又单独做了一个账本（**元数据**），里面存储了每条鱼存放在冰箱什么位置的信息。\n\n2. 烹饪不过来：\n\n鱼越来越多，即使所有的鱼都能保存到冰箱中，但是只有一个厨师的话效率实在太低。\n不如多找几个厨师，大家一起烤（分布式计算）\n## \n所以说，大数据技术本质上用于解决 海量数据提取、存储、处理的一套技术，分布式是其主要实现思路。\n\n## 重要结论\n\n**学术界普遍认为大数据仍处于发展与创新的初始阶段**。大量数据的存储并不是大数据技术的主要问题甚至不是重要问题，非结构化的数据的快速处理与分析利用才是大数据要解决的最主要问题。\n\n**大数据是相对的**，大数据的概念也是不断变化的。（三十年前100M也是大数据）大数据是指用现有技术手段和软件难以快速处理的数据。今天的大数据主要强调数据的非结构性与实时处理的要求。\n\n**人是大数据中重要的环节，数据可视化是实现人的作用的主要工具** 大数据强调人通过数据可视化对大数据运算结果的再次分析与知识提炼，以便进行进一步的数据挖掘。\n\n** 大数据的四个特点：**\n- Volume 数据量大\n- Velocity 速度快\n- Variety 种类多样\n- Value 价值密度低\n\n\n# 一、云计算\n\n## 大数据对于系统架构的需求\n\n为了对应大数据的几个基本特点：Volume(数据量大) Velocity(产生速度快) Variety(种类多)  Value(价值密度低)。因为以上几个特点，大数据对于数据架构的需求如下：\n\n- 显示的需求\n    - 海量计算和存储  ➡️  数据量大\n    - 快速计算  ➡️  产生速度快\n- 隐式的需求\n    - 数据的快速传输  ➡️  产生速度快\n    - 灵活性  ➡️  种类多\n    - 低成本  ➡️  价值密度低\n\n## 大数据的核心设计理念\n\n- 并行化\n    -  并行请求\n    - 并行进程\n    - 并行指令\n    - 并行数据\n    - 硬件描述\n- 规模经济  例子：WSC（仓库规模的计算机） 用网络链接起来的计算和存储设备。实用相对同质的硬件和系统软件平台、共享相同的系统管理、运行相对小数目的超大型程序、通用的资源管理架构增强了灵活性。\n    - 主要部件\n        - 供电、制冷、建筑、网络、安全\n        - 存储、计算\n    - 优势\n        - 规模经济\n        - 提高使用率\n    - 挑战\n        - 能耗PUE = Total Energy/Computer Energy\n        - 运维\n- 虚拟化（抽象） 解决多租户、多应用使用的问题 \n  \n  > 计算机科学中的所有问题，都可以通过增加一个层次的间接(indirectiron)来解决，当然除了间接层次过多的问题 —— David Wheeler\n\n虚拟化的结果 —— 每个用户认为自己有一套自己的架构，而实际所有人共享相同的硬件资源。\n\n![](http://doc.xr1228.com//post-images/1579969064114.png)\n\n\n# 二、虚拟化技术\n### 为什么要虚拟化？\n传统的虚拟化的目的主要是为了分区与抽象\n- 分区 Partitioning\n    - 分享：打破一个大资源\n    - 服务器\n- 抽象 Abstraction\n    - 用一个指令集仿真另一个指令集（简而言之就是一种操作系统使用另外一种系统）\n  \n在云计算时代，虚拟化是为了资源池，安全，便于管理\n- 资源池\n    - 聚合：将多个资源结合起来\n    - 合一：利于存储\n    - 动态：快速分配（虚拟机）\n- 隔离：保护消费者隔离其他租客\n    - 例如虚拟专用网（VPN）\n- 便于管理\n    - 测试\n    - 机动性\n  \n### 数据中心虚拟化的三个重要内容\n- 计算虚拟化\n  - 主操作系统：运行在真实机器上\n  - 客户操作系统：运行在主操作系统之上\n  - Hypervisor：支持运行在多个虚拟机上的软件\n    - 类型1:运行在真实机器上，例如 Xen、VMWARE、ESXi\n    - 类型2:运行在主操作系统，例如 MS Virtual PC\n    - 类型0:1和2兼有，例如 Linux KVM\n- 存储虚拟化\n- 网络虚拟化\n\n### 服务器虚拟化考虑的三个问题\n- 指令集的翻译 二进制翻译\n    - 如何快速执行\n    - 如何执行需要更高权限的指令\n- I/O设备的仿真\n    - 如何让虚拟机操作系统访问不支持的硬件\n    - 如何保护I/O性能\n- 保护处理器的数据结构 **影子**处理器\n\n### 虚拟化的核心问题：内存的保护管理\n![](http://doc.xr1228.com//post-images/1580566550776.png)\n计算机的内存映射是由MMU进行管理，当计算机虚拟化后运行在计算机上的多个系统对于MMU的控制方式是内存保护管理的重要问题。目前的解决方式：\n- 半虚拟化：修改虚拟机操作系统，能不做操作就不要作\n- 影子页表：\n    - 拒绝客户操作系统对实际页表条目的任何访问\n    - 捕获访问请求，在软件中仿真\n- 硬件支持的虚拟化：\n    - 二级地址转表（SLAT）\n        - AMD AMD-V RVI\n        - Intel VT-x EPT\n  \n> MMU是Memory Management Unit的缩写，中文名是内存管理单元，有时称作分页内存管理单元（英语：paged memory management unit，缩写为PMMU）。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制。\n\n### 网络虚拟化\n#### 网络虚拟化的用途\n![](http://doc.xr1228.com//post-images/1580567311758.png)\n#### 网络虚拟化的举例 ： VLAN\n最简单的目标：提供单一的二层网络\n- 端口分数不同的VLAN\n- 多个VLAN共享一个端口\n    - Trunk模式\n    - VLAN标签（12bits）：特殊的包头\n    - 最多支持4096 VLAN\n- VLAN的优劣与解决方案\n    - 优势：标准，支持广泛，硬件成本低\n    - 劣势：只能支持4096个VLAN\n    - 新的标准：VxLAN\n        - 通过三层隧道实现\n        - 广播 -> 组播\n        - Virtual Tunnel End Ppoints（VTEPs）负责打包和接包\n#### 现代网络虚拟化技术：软件定义网络\n- 传统网络\n    - 控制面与数据面集成在同一个设备中\n    - 不同网络设备之间通过协议决定如何转发\n- 软件定义网络\n    - 控制面集中管理，放在服务器中\n    - 举例：OpenFlow协议，每一层交换机通过Controller确定数据流向\n  ![](http://doc.xr1228.com//post-images/1580614390079.png)\n    - 举例：Portland —— 大规模的虚拟二层网络的实现\n        - 大型2层网络的挑战\n            - 地址解析（ARP）：广播\n            - 路由：广播\n            - 转发：交换机要记住大量状态\n            - 根源：MAC地址不连续\n        - Portland实现\n            - 与位置相关的虚拟地址\n            - 通过SDN的地址解析\n                - 网络截获所有ARP广播\n                - 把无序的MAC地址改成与物理位置相关的地址\n                - 转发数据包\n                - 发给服务器之前，改回原来的MAC地址\n  #### 存储虚拟化\n  - 存储的意义\n    - 独立于数据位置\n        - 扩展性强，容量大\n        - 易于管理（磁盘可集中存储）\n        - 提升磁盘使用率\n    - 独立与物理存储技术\n        - 易于升级\n        - 可用性的优化（多路径访问、冗余）\n        - 易于维护（在线的后台备份、恢复）\n- 存储虚拟化的三类接口\n    - 块接口\n        - 本例块存储\n        - 远程块存储接口\n    - 文件接口\n        - 文件系统\n        - 网络文件系统（NFS，CIFS，HDFS）\n        - VFS\n    - 对象存储接口\n        - 亚马逊S3（基于http协议的REST接口）\n        - OpenStack Swift\n- 存储虚拟化的实现方式\n    - SAN 存储区域网络\n        - Storage Area Network\n        - 存储服务器通过专用网络链接，例如光纤通道（FC）\n    - NAS 网络附接存储\n        - Network attached storage（NAS）\n        - 存储服务器通过通用网络来访问，例如以太网\n### 总结\n- 优势\n    - 统一、抽象的接口隐藏了复杂的物理硬件\n    - 灵活，可以软件定义\n    - 易于管理，更容易保证安全\n- 问题\n    - 虚拟化有一定的资源开销\n    - 通常没有实现性能的隔离\n    - 过多层的抽象：如何调试 ？\n- 发展趋势：软件定义数据中心？\n    - 网络功能虚拟化\n        - 防火墙、入侵检测系统虚拟化\n    - 资源的管理和调度\n    - 其他资源的虚拟化：空调？供电？建筑？\n    - 目标：性能+灵活性+管理\n\n\n\n# 三、典型的云计算系统\n### 一个虚拟机的生命周期\n![](http://doc.xr1228.com//post-images/1580630632121.png)\n\n1. 用户通过界面或命令行向API发送 ‘create instance’\n2. API节点记录虚拟机信息，发送调度请求给调度器\n3. 调度器找到可用的计算节点，向计算节点发送‘vm provision’请求\n4. 计算节点通过虚拟机hypervisor启动虚拟机\n5. Hypervisor去**镜像存储服务**获取虚拟机磁盘镜像\n6. 计算节点向网络节点发信息，请求给新创虚拟机分配网络资源\n7. 网络节点通过配置虚拟交换机配置网桥、VLAN等，实现虚拟网络，并在数据库中记录网络信息\n8. 计算节点向虚拟存储服务要求新建虚拟磁盘卷，并通过iSCS协议挂载\n9. 用户通过界面查询虚拟机创建的结果\n\n> 以上操作是异步\n\n### 什么是一个好的云计算系统\n- 让用户彻底忘记底层的硬件（通过好的虚拟化和抽象，让用户忘记复杂的硬件与运算逻辑）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【工业与大数据】大数据基础",
        "date": "2020-01-23 23:59:47",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/da-shu-ju-de-ji-chu-jia-gou-yun-ji-suan.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n大数据这个词已经火热了很多年，似乎处处都存在着大数据的噱头，让我们回归本质，探讨一下大数据是什么？\n本文介绍了大数据技术细节以及相关背景的的一些概念。本文并未对大数据的相关知识进行总结，所以本文仅作为参考，无需详细阅读。",
      "fileName": "da-shu-ju-de-ji-chu-jia-gou-yun-ji-suan"
    },
    {
      "content": "接下来，让我们一起来完成一项具有一定实际价值的工作吧!\n\n在数据可视化领域，我们经常会使用**词云**来对文字中词语频率进行统计。网络当中也有许多类似[Wordle](http://www.wordle.net/) 、[图悦](http://www.picdata.cn/picdata/)图云生成网站。不过佛家有一句禅语：\n> 莫向外求，但从心觅\n\n我们可以片面的将这句话用在编程当中——双手敲过的代码才属于自己。 接下来就让我们通过Python自己编写一个词云生成器吧！\n\n首先是效果图，我节选了BOE(目前国内最大的面板生产企业)现任董事长在2018年全球创新合作伙伴峰会中的演讲，让词云通过分析这篇演讲稿来看看这位企业家为合作伙伴勾勒出的物联网蓝图是怎样的：\n![](http://doc.xr1228.com//post-images/1579701301281.png)\n\n服务、技术、创新这些词语在演讲中被大量提及，通过这样一张图片，就能对这篇演讲的大概内容有一定的了解。那么Python是如何生成这样一副文字大小颜色方向各异的复杂图片呢？\n其实十分简单，仍旧是老规矩，NoBB，Show Code！\n\n```python\n# 词云图\nimport matplotlib.pyplot as plt\nimport jieba\nfrom wordcloud import WordCloud\nfrom os import path\n\nlocalpath = path.dirname(__file__)  # 获取当前工作路径\n# 获取文件，注意这里要看编码格式\ntext = open(localpath+r'/words.txt', 'r', encoding='UTF-8').read()\n# 剪切单词\ntext_cut = jieba.cut(text)\n# 单词拼接\nresult = ' '.join(text_cut)\n# 生成次云图\nwc = WordCloud(\n    # 字体路径\n    font_path=localpath + r'/simhei.ttf',\n    # 背景颜色\n    background_color='white',\n    # 图片宽度\n    width=500,\n    height=350,\n    # 字体的大小\n    max_font_size=70,\n    min_font_size=5,\n)\n# 生成词云图片\nwc.generate(result)\nplt.imshow(wc)\nplt.axis('off')\nplt.show()\n```\n\n你一定很惊讶短短20多行代码就实现了词云这样复杂的功能。这都归功于Python丰富的各类库\n请允许我再次唠叨一下库的定义。\n\n- 所谓库就是Python提供的实现一类功能的具有目录层次结构的程序集合。\n\n简而言之，库就是Python提供给我们的，帮我们实现功能的工具包，每个工具包都能实现一个或者一类功能。本次程序我们用到了四个库：\n\n- matplotlib：Matplotlib是一个Python 2D绘图库，它能够快速辅助数据分析人员生成图表、直方图、功率谱、条形图、误差图、散点图。pyplot是Matplotlib的一个命令风格函数的集合，使matplotlib的机制更像 MATLAB，matplotlib的pyplot子库提供了和matlab类似的绘图API，方便用户快速绘制2D图表。\n- jieba：jieba是一种中文分词组建，他通过一定计算逻辑可以将一句完整的中文句子拆解成一个个词语。\n- wordcloud是Python用于构建词云的工具包，其功能强大，支持自定义词云各项参数。\n- path：这是Python标准库（自带的、无需安装的）中提供的用于文件访问、处理的库\n\n通过调用这些库的API，我们就能够很容易的实现词云这样复杂的图片。\n你肯定已经早早将程序敲到电脑中编译运行了，但是却出现了这样的错误：\n\n```cmd\n发生异常: ModuleNotFoundError\nNo module named 'matplotlib'\n```\n\n为什么呢？因为我们的程序中使用到了matplotlib、jieba、wordcloud这些外部库，外部库需要我们下载安装到自己电脑上才可以运行。坏消息是我们要下载三个库才能保证程序正常跑起来，好消息安装三个库非常容易！\n\n之前我们提到了包管理器，python内置了包管理器，使用包管理安装外部库的命令格式如下：\n\n```cmd\npip3 install SomePackage  \n```\n\n注意这里是pip3（在python进入3.X时代包管理应当使用pip3这个命令）\n\n接下来让我们开始安装所需的三个外部包。打开命令行程序（windows系统 开始➡️运行➡️cmd，MacOS系统使用终端）\n\n```cmd\npip3 install matplotlib  #安装matplotlib\n\npip3 install jieba  #安装jieba\n\npip3 install wordcloud  #安装wordcloud\n```\n\n不出意外的情况下这些包就都安装好了，如果安装过程中有疑问，最好百度/Google/dogedoge一下，善用搜索引擎。\n万事俱备只欠东风，接下来我们逐行对程序进行分析。\n\n```python\nimport matplotlib.pyplot as plt\n```\n\n- 这句话翻译成汉语很简单:引用matplotlib库的pyplot功能包，并将其命名为'plt'\n- matplotlib.pyplot 也可以写为  from matplotlib import pyplot这样的形式，这种形式我们在后面也会遇到，只需知道他的意思就是从matplotlib库中调用pyplot功能即可\n- 为什么要将其 as plt呢？ 很明显，就是因为 matplotlib.pyplot 太长了，后面我们要多次用到这个命令，索性给他起个名字，方便后续书写。这个名字可以随便命名（尽量符合驼峰命名规则）\n\n```python\nimport jieba\nfrom wordcloud import WordCloud\nfrom os import path\n```\n\n很简单，就是引入其他几个所需的库。（这里三个包都没有使用别名，因为本身长度就不长）\n\n```python\nlocalpath = path.dirname(__file__)  # 获取当前工作路径\n```\n\npython是一种若类型语言，所以我们定义变量“localpath”的时候并没有像其他编程语言一样 使用 string 类型符\n这句代码的意思是：定义一个变量“localpath”，给这个变量赋值为 当前工作路径。\n如何获取当前工作路径呢？使用的方法就是path.dirname(__file__)，这是Python os库中自带的方法，是不是非常方便？\n\n```python\n# 获取文件，注意这里要看编码格式\ntext = open(localpath+r'/words.txt', 'r', encoding='UTF-8').read()\n```\n\n这句话定义了一个变量 text，将工作目录下的 words.txt中的文字赋值给它。\n这里用到了一个 python的open()函数，open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。\nopen()函数代码格式如下：\n\n```python\nopen(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\n```\n\n- file: 必需，文件路径（相对或者绝对路径）。\n- mode: 可选，文件打开模式：只读，写入，追加等。我们采用了r模式，即默认文件访问模式。\n- buffering: 可选，设置缓冲，-1为采用系统默认缓存大小，0表示不使用，1表示使用，大于1的数字表示缓存区大小\n- encoding: 一般使用utf8（可以正常读取中文）\n- errors: 报错级别\n- newline: 区分换行符\n- closefd: 传入的file参数类型\n\n这个时候你可能有些疑惑🤔，道理都懂，但是为什么open()这个函数在这里要这样写？因为该教程的前半部分主要面向初学者，我们也没有经历过系统性的基础学习，这里对 编程语言中方法（函数）的调用进行说明。\n\n比如本例中 open(localpath+r'/words.txt', 'r', encoding='UTF-8') 这个语句\n\n- open()表示方法名，告知计算机我调用的是什么方法（函数）\n- open中所有内容，我们称之为参数，不同参数用\",\"分开。也就是说在本例中，我们调用open()方法，这个方法使用了三个参数\n- 第一个参数告知计算机文件的路径，localpath+r'/words.txt'  即工作目录下的words.txt文件\n- 第二个参数告知计算机我们采用 r 的模式读取文件（只读）\n- 第三个参数告诉计算机我们用的编码模式\n- 给方法定义参数的这个动作我们称之为 **传参**\n\n希望这样的解释能让你对编程工作中最基础最重要的 方法和参数有基本的理解。\n\n```python\n# 剪切单词\ntext_cut = jieba.cut(text)\n```\n\n这一句，我们调用了jieba的cut方法，将刚刚获取的文件内容text传如cut方法，这样jieba就将我们的text自动分词，分为一个一个单词组成的词组。最后将词组赋值给新定义的变量 text_cut\n\n```python\n# 单词拼接\nresult = ' '.join(text_cut)\n```\n\n这里有调用了一个join方法，传入我们的数组text_cut。什么意思呢？就是将这分好的一个个词语组合起来，使用空格隔开，组合成一个字符串。\n到这里，我们对于文章的处理就结束了，我们将原来的文章分成一个个词语，每个词语用空格隔开。为什么要这样处理呢？没有别的原因，就是因为我们后续调用的 wordcloud库就是这样规定的，他只能识别这样形式的数据。\n\n```python\n# 生成次云图\nwc = WordCloud(\n    # 字体路径\n    font_path=localpath + r'/simhei.ttf',\n    # 背景颜色\n    background_color='white',\n    # 图片宽度\n    width=500,\n    height=350,\n    # 字体的大小\n    max_font_size=70,\n    min_font_size=5,\n)\n# 生成词云图片\nwc.generate(result)\n```\n\n这里看似复杂，其实更加简单，我们调用了wordcould的方法，并在方法中传入若干参数，通过这些参数定义我们生成词云的样式。\n这里尤其需要注意 font_path=localpath + r'/simhei.ttf' 这一句必不可少，因为wordcloud必须知道自己使用的字体文件是什么样的才能正确生成词云。所以我们在工作目录中放入了一个simhei.ttf字体文件，方便wordcloud调用。\n\n这样我们的一个词云生成器 wc就定义好了，后续再调用 generate()方法并将处理好的数据变量result扔进去即可。\n\n```python\nplt.imshow(wc)\nplt.axis('off') \nplt.show()\n```\n\n词云做好了，如何让它显示出来？\n\n- 调用plt（就是开头引用的2D图像生成包）中imshow()方法将wc图片进行显示，\n- 调用plt.axis('off')让它不要生成坐标轴\n- 调用plt.show()方法使其显示出来。\n\n这样我们点击运行后一张词云图就显示出来了，注意工作目录中用到的 word.txt文件，simhei.ttf放在[github](https://github.com/Wuriqilang/WordCloud)中，你可以自行下载。如果不会使用github下载也没关系，自己在网上任意下一个ttf的字体文件，自己随便写一个word.txt文本文档放到我们写的python程序目录中即可。\n\n虽然我说的琐碎，但是在实际编写过程中相信你还是遇到许多问题，失败多次，各种环节出现奇葩的我没有提到的问题。\n没关系，多查多想多问。遇到问题，请在下方留言区留言\n\n[更多词云资料](https://zhuanlan.zhihu.com/p/27626809)\n[本例源代码](https://github.com/Wuriqilang/WordCloud)",
      "data": {
        "title": "【编程只是工具】Python实用手册03 词云",
        "date": "2020-01-22 21:53:45",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python-shi-yong-shou-ce-03-ci-yun.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-shi-yong-shou-ce-03-ci-yun"
    },
    {
      "content": "虽然说学习一门语言，通常都是从命令行开始的。因为命令行涉及到的知识点最少，也不需复杂的功能依赖，初学者在命令行程序中很容易掌握各种语言的特性。但是这种相对枯燥乏味的学习方式很容易让人产生挫败感，花费数个小时研究学习后展示在我们眼前的就是冷冰冰的几行数字。所以让我们从 UI 编程开始学习，结合实际例子来快速入门吧。\n\n请在 VS Code 中新建一个.py 文件，输入以下内容。注意从现在开始，程序的输入切勿复制粘贴，自己敲进去代码和复制粘贴感觉是不同的！\n\n```python\nimport tkinter #引入Tkinter功能模块\n\nroot = tkinter.Tk() #实例化一个视窗对象\n\nmyLabel = tkinter.Label(root, text=\"Welcome to python's World\")  #在视窗对象中实例化一个Label对象\nmyLabel.pack() #将对象放在窗口中\n\nroot.mainloop()  # 进入主窗口消息循环\n```\n\n点击运行（F5）后,出现就出现了第一个属于你的 Python 视窗\n\n![](http://doc.xr1228.com//post-images/1579701131042.png)\n\n让我们来详细讲解以下这段代码：\n\n```python\nimport tkinter #引入Tkinter功能模块\n```\n\n什么叫做引入？什么叫做 Tkinter？\n\n- 引入：顾名思义，就是引用其他人写好的功能集（库）。这个功能有可能是 Python 内置的，也有可能是我们从包管理器下载来的。通过引入，我们就能用一行代码调用前人辛苦写好的功能，快速实现我们自己的需求。\n- Python 与包：Python 与包的关系，就如同工程师与设备的关系。今天工程师需要实现制作一个手机，那么我们就调来（引入）一个专门制作手机的机器，我不管这个机器是怎么造出来的，只要机器能生产出我们想要的手机即可。\n- 包管理器：接着上面的类比，工程师今天不想造手机了，想直接造人民币。但我们并没有现成的人民币制造机，怎么呢？我们进口一台人民币制造机就可以了。包管理器就是我们去进口机器的地方。——包管理器中存放着数以万计的凝聚力无数人心血的功能包，我们想要调用包管理器中的包时，只需要在命令行中输入“pip install ....(包的名字)“即可。 本例并未使用包管理器，后续我们会接触到。\n- Tkinter：Tkinter 模块(Tk 接口)是 Python 的标准 Tk GUI 工具包的接口。啥意思？就是说这就是一个 Python 中已经内置的专门用来画用户界面的包。\n\n所以说，这行代码乍看起来不明白，说白了就是调用一个用来画用户界面的包。\n\n```python\nroot = tkinter.Tk() #实例化一个视窗对象\n```\n\n如果你接触过其他编程语言，就会发现这条语句似曾相识却又有所不同。我们先来解释这几个刚看到的名词。\n\n- 对象：简而言之就是具有某些功能和特性的抽象化集合。面向对象的编程思想中，世间万物都可以抽象为对象。所谓“晓看天色暮看云，行也对象，坐也对象“。上述代码中的root，就是我们所需要的视窗对象，而tkinter.TK()，则是生成对象的方法。\n- 对象的实例化：其实举一个例子就很好懂。张无忌对对敌光明顶，想要使出一招乾坤大挪移，然而乾坤大挪移并不是一个实实在在的物体，怎么做呢？**他按照《九阳神功》的口诀，调用体内真气流转将乾坤大挪移激发出来。**这个过程就是**实例化**。\n\n![](http://doc.xr1228.com//post-images/1579701158947.gif)\n\n所以说, tkinter.TK() 就是九阳神功中运转乾坤大挪移的法门，root 则是我们实例化出得乾坤大挪移对象。只有将对象实例化后，我们才能操作他完来成一系列任务。\n\n希望前面的解释能让你能对编程世界中最常用的几个概念有所体会，事实上编程就如同搭积木一样，我们调用不同的积木，采用不同的组合最后实现自己的目的。在工业实践应用中，参与编程的工程师并不需要早早了解多么深刻的编程原理和数据结构，我们能够熟练使用这些积木，搭建出想要的城堡就够了。\n\n此时，视窗对象已经完成了实例化，我们希望这个视窗能够显示一个句子。所以我们要继续实例化出一个标签对象来承接我们的句子。所以我们用到了这样一条语句。\n\n```python\nmyLabel = tkinter.Label(root, text=\"Welcome to python's World\")  #在视窗对象中实例化一个Label对象\nmyLabel.pack() #将对象放在窗口中\n```\n\ntkinter.Label()就是生成Label对象的方法。而括号中的内容，则是**方法的传参**\n\n- 方法的传参：不要觉得这么多生词很难理解，其实简而言之，就是我们调用方法的时候，给定一些基本参数，让方法按照我们的设定执行。譬如我们调用了一个 \"做饭.鱼香肉丝()\"的方法，如果我们想要设定 肉300g,盐20g，在编程语言里就可以写成 “做饭.鱼香肉丝(肉=300，盐=20)“这样的形式。是不是很好理解呢？\n- 解释这条语句：为了实例化出一个标签对象，我们采用tkinter.Label()的方法，在这个方法中我们传入两个参数，\n  - 第一个参数：root。这是告诉这个方法，我们的Label是在root中生成的。\n  - 第二个参数：test。这是告诉这个方法，我们的Label要显示test中的内容。\n- myLable.pack():对象实例化出后还有一个重要步骤，就是让他显示出来，让Label显示出来的的方法是myLabel.pack().\n  \n**到这里你一定非常迷惑——为啥要这么写？我怎么可能记住这么多方法？**\n- 为啥要这么写？ ——这是tkinter的作者规定的，你按照他的规定写就好了，以后当你自己写方法的时候你也可以很方便的规定他。\n- 我怎么可能记住这么多方法？ —— “唯手熟尔”，当然装B的说法就是，这些常用的方法很好记的，不信你写几次就知道了。即使记不住也没关系，google以下即可。\n\n\n```python\nroot.mainloop()  # 进入主窗口消息循环\n```\n\n最后一句也很好理解，就是让我们的视窗对象在运行起来。\n\n希望这篇文章能对你有帮助，如果有任何疑问可以在下方评论区提出。",
      "data": {
        "title": "【编程只是工具】Python实用教程02  Python UI编程",
        "date": "2020-01-22 21:51:17",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python-shi-yong-jiao-cheng-02-python-ui-bian-cheng.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-shi-yong-jiao-cheng-02-python-ui-bian-cheng"
    },
    {
      "content": "让我们做一个小游戏吧,体会一下 Python 独特的魅力。\n<!-- more -->\n\n\n请在 VS Code 中新建一个.py 文件，或者是在命令行管理器中输入 Python（MacOS 输入 Python3）写入以下内容。\n\n```python\nprint('\\n'.join([''.join([('Chinese！'[(x-y)%8]if((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3<=0 else' ')for x in range(-30,30)])for y in range(15,-15,-1)]))\n```\n\n点击运行（F5）后,出现了一个中国心。是不是很有趣？将代码中 Chinese！ 修改为喜欢的姑娘的名字送给她吧！(注意必须是 8 个字符)\n\n![](http://doc.xr1228.com//post-images/1579701034908.png)\n\nPython 的魅力远不止于此,这段代码初学者还不需要明白是什么意思，让我们赶快进入到后面的学习吧！",
      "data": {
        "title": "【编程只是一种工具】Python实用教程01  一句话表白 ",
        "date": "2020-01-22 21:49:28",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python-jiao-cheng-01.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "让我们做一个小游戏吧,体会一下 Python 独特的魅力。",
      "fileName": "python-jiao-cheng-01"
    },
    {
      "content": "\n> 人生苦短，我用 Python。 ——鲁迅\n\n## 写在开头\n\n本文档专注于编程语言在工业领域的实际应用，以实例讲解为主，还原编程语言的工具属性。这里会主要告诉你一个“工具怎么用”、“为什么要用”，但是不会过多涉及到“工具如何制造”以及“怎么用才更好”的问题。\n\n## Why Python\n\n- **天生优雅：** Python 使用了极为优雅精炼的语法与程序结构，一个简单的程序 C与JAVA 可能需要200行，而Python仅仅需要20行。Python提供了大量语法糖（或许你曾在比较各种语言优劣时听过这个词）Python就是将许多复杂的代码实现转化为精炼优雅符合人类直觉的书写方式，实用Python写程序时就如同孩子在吃糖果。\n- **开箱即用：** Python 提供了极为完善的基础代码库，很多看似复杂的程序实现可能仅仅需要调用Python中的一两个方法。对于一些复杂的图形处理，数据分析仅仅需要引入一两个依赖就能调用前人写好的功能模块。\n- **无所不能：** 受益于Python目前的热度，这个已经走过30年岁月的语言焕发出了无穷的活力。Python能够胜任从数据库，网络编程，机器学习各方面的应用。\n\n## Python 安装\n\nPython安装请选择最新版本3.7，网上有许多安装教程，这里不再赘述。[Python安装](https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624)\n\n## 选用的编辑器\n\n按照编者的使用习惯，这里推荐使用VS Code作为您的Python编辑器。VS Code有以下优点：\n\n- 开源，免费；\n- 自定义配置\n- 集成git\n- 智能提示强大\n- 支持各种文件格式（html/jade/css/less/sass/xml）\n- 调试功能强大\n- 各种方便的快捷键\n- 强大的插件扩展\n简而言之，掌握了VS Code，你不但可以如丝般顺滑的编写Python程序，你具有了编写前端网页，Nodejs，文档……的能力。这样一把由微软打造的神兵谁会不喜欢呢？ [vs Code官网](https://code.visualstudio.com/)\n\n## VS Code安装汉化插件\n\nVS code安装汉化插件非常简单，打开vs Code后，选择左侧菜单栏中的插件商店，输入Chinese后选择Chinese (Simplified) Language Pack for Visual Studio Code点击 Install 即可。\n\nVS Code有很多优秀的插件能够极大的拓展VS Code功能，但如果你是编程初学者，建议先不要安装，让我们将更多注意力放在Python本身，以后按照自己的需要逐步拓展VS Code功能。\n\n## 一些学习Python的资源\n\n- Python基础学习 [廖雪峰Python教程](https://www.liaoxuefeng.com/wiki/1016959663602400)\n- 实用Python脚本学习视频 [实用主义教你学Python脚本](https://www.bilibili.com/video/av45221676)\n- [Tkinter 做简单的窗口视窗](https://www.bilibili.com/video/av16942112)\n",
      "data": {
        "title": "【编程只是一种工具】Python实用教程   介绍",
        "date": "2020-01-22 21:45:15",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python"
    },
    {
      "content": "\n## 一、为什么智能制造\n2016年7月，京东方的业务定位由一家半导体显示技术、产品和服务提供商转型为一家为信息交互和人类健康提供智慧端口产品和专业服务的物联网公司。在践行智能制造的过程中，我们开发了一套应用于京东方面板生产产线的设备智能监控系统。旨在消除设备监控死角，节约不良调查时间，减少工厂生产运营人力成本。将设备监控从“发现不良→调查设备→解决问题”的被动模式转化为”设备监控→预防不良”的主动模式。通过充分挖掘企业数据潜能，建立一套可视化、智能化的设备监控系统，将工程师从繁复的日常监控工作中解放出来,为公司运营提供长久动力。\n### 1.1 Array智造整体架构\n如何真正实现智能制造，将智能化生产应用于实际工厂运营当中来不同工厂有不同的思路。通过对我国智能制造试点示范项目进行分析，梳理出如下九种典型的智能制造新模式：\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567583134061-9095d2cc-1ced-4460-a1d0-b20f5a119eaa.png#align=left&display=inline&height=386&name=%E5%9B%BE%E7%89%87.png&originHeight=386&originWidth=587&size=118189&status=done&width=587)\n\n\n工厂的智能化程度取决于其对数据的利用程度。结合对京东方自动化程度以及实际生产制造模式，设计了一种以挖掘企业数据潜能为核心的智能制造模式。\n设备智能监控系统是一套建立在BOE工厂现有CIM系统基础上，以挖掘数据潜能为核心思路而设计的数据采集、处理、分析系统。这个系统由以下几个节点组成：\n1.设备端：高度信息化的设备实时信息发送给MES系统，通过EIS对信息格式进行统一。\n2.CIM端：通过MES、YMS、DFS、eMpa、SPC、BO等系统将生产信息，测试信息进行汇总处理，并提供端口供设备智能监控程序调用原始数据。\n3.监控端：智能监控程序将原始数据进行分析处理最后生成可视化程度、集成度高的信息反馈给工程师，并展示在Monitor看板，以便管理者掌握生产运营状态。\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567583254106-8d646a0c-d511-4e26-8363-63e59382842a.png#align=left&display=inline&height=320&name=%E5%9B%BE%E7%89%87.png&originHeight=320&originWidth=548&size=74161&status=done&width=548)\n\n\n所以说Array智造软件专注于应用层的开发，通过整合现有数据资源，通过软件来优化工程师工作效率，减少无用的重复的劳动。\n\n### 1.2 Array智造的基础 —— 数据\n本节重点介绍Array智造中的数据如如何获取的，并介绍了两个采集数据的软件。\n为了便于理解，下面将通过不同功能的的数据源获取方式来依次介绍Array智造的数据模块。\n#### 1.2.1 AOI Monitor的数据获取\nAOI Monitor在设计之初是单纯为日常Monitor工作服务的，所以采用了单一数据源 —— DFS\n\n- DFS 是公司提供的分布式文件存储服务，对于我们业务部门来说，其使用体验等同于共享。\n- 目前DFS 的统一访问地址是  10.120.8.52  账号是 dfssrv2\\cifsa  密码是 cifsa \n- 注意：AOI Monitor为访问Inform等常用功能开放了快捷方式，后续担当可以根据业务需求修改\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567584769308-57815052-ea59-4897-8f98-fb85eaaac450.png#align=left&display=inline&height=192&name=%E5%9B%BE%E7%89%87.png&originHeight=192&originWidth=226&size=7897&status=done&width=226)    ![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567584583410-1027da76-f284-42dd-93d9-7359c56a053f.png#align=left&display=inline&height=178&name=%E5%9B%BE%E7%89%87.png&originHeight=178&originWidth=404&size=39133&status=done&width=404)\n#### 1.2.2 CD Monitor的数据获取\nCD Monitor的数据流是 CD设备→曝光机共享→Monitor软件  来进行的，其获取数据的手段都是通过FileGee软件，该软件会在后面重点介绍。 该部分由马晓宇负责，如由疑问联系马晓宇。\n#### 1.2.3 IM Monitor的数据获取\nIM Monitor的数据来源如下：\n\n- DFS   包含了用户查询的IM Monitor图片信息\n- FTP   IM监控电脑不能访问共享，所以提交Abnormal时会先将Abnormal数据传到\n> FTP://10.120.9.22/【7】IM Abnormal\n\n- 共享  所有的Abnormal图片都会在存储在新共享\n> \\\\10.120.21.123\\Photo共享\\42.Photo工程部工作优化小组\\Array智造\\MuraHistor\n\n\n所以IM Monitor的数据流向如下\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567586067028-e975c41e-9c89-48cc-9b56-597a0626b153.png#align=left&display=inline&height=349&name=%E5%9B%BE%E7%89%87.png&originHeight=349&originWidth=1096&size=11649&status=done&width=1096)\n#### 1.2.4 THK Monitor\nTHK Monitor数据来源全部为共享，数据流如下\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567586183451-5e1e7fb1-b0a9-4bbe-98a5-7f7866258f86.png#align=left&display=inline&height=121&name=%E5%9B%BE%E7%89%87.png&originHeight=121&originWidth=1053&size=6779&status=done&width=1053)\n值得注意的是THK共享近期没有进行维护，后续担当需要开启。\n#### 1.2.5 设备监控\n设备监控中所有的数据都是从设备ProcessData中获取的，当我们将ProcessData保存到共享中，Array智造软件就可以方便的对数据进行处理和展示。其数据流向如下：\n\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567586828504-61a29a83-9785-4c56-9734-d43c4a0895ce.png#align=left&display=inline&height=667&name=%E5%9B%BE%E7%89%87.png&originHeight=667&originWidth=1110&size=29880&status=done&width=1110)\n\n值得注意的是：每天设备的数据现在设备上使用FTP Ghost软件简单处理后再利用FileGee进行上传\n\n#### 1.2.6 不良监控\n不良监控为了将各台设备的AOI Trend和工艺相关联起来，采取了比较复杂的数据获取方式。\n其数据获取方式与设备监控数据获取类似，重点在于将设备的工艺数据与DFS的测试数据相结合起来。\n\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567589162513-c0c2b6b2-ecb0-45c2-a1e7-ee86bfdb0c17.png#align=left&display=inline&height=659&name=%E5%9B%BE%E7%89%87.png&originHeight=659&originWidth=1106&size=30516&status=done&width=1106)\n#### 1.2.7 产能监控\n产能监控数据获取与设备监控相同，请参考 6.2.5\n\n\n#### 1.2.8 数据处理软件 参考附件【14】\n不难发现，上述各种数据获取离不开两个软件 FileGee与FTP Ghost。 具体使用方法较为复杂，已经单独交接给相关担当，软件请参考附件【14】\n\n### 1.3  智能制造的具体实现\n本节将介绍各软件模块的功能与基本实现思路，便于后续担当对软件进行进一步开发与维护。\n\n#### 1.3.1 AOI Monitor\nAOI Monitor目的是简化工程师日常Monitor流程，方便数据信息获取与基本的不良调查，其功能必须配合DFS使用，即用户电脑要开启DFS权限。AOI Monitor主要功能与实现如下：\n**AOI Monitor部分**\n\n\n- 通过LotID查询所有测试过得工序\n- 点击相应工序后显示测试过得Glass并且计算Total，对于异常Total使用红色显示\n- 点击跳转到DFS后能快捷跳转到DFS中，便于工程师看图\n\n**Tracing工具部分**\n\n- 通过GlassID查询所有测试过的工序\n- 多工序匹配Tracing结果，已经抓图的显示匹配结果，有Defect未抓图显示粉色背景，没有抓图显示灰色\n\n这里着重说一下Tracing工具的实现方式：先通过Data文件夹将所有Defect点位获取，匹配后（匹配规则是如果两个工序的点 X+Y的差＜0.5um且Y的差<0.5认为这两个点能够匹配到）筛选出查询到的Defect点并到Image文件夹中根据坐标找相应的图片，将图片地址存储到数据列表中，最后通过一定规则显示出来。\n\n\n#### ![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567588150931-63e193b6-bbd9-4e61-bc70-942ca4601f84.png#align=left&display=inline&height=220&name=%E5%9B%BE%E7%89%87.png&originHeight=823&originWidth=1130&size=415771&status=done&width=302)        ![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567588691160-49d5e579-b6bc-4cac-ac67-0d3662c67fa4.png#align=left&display=inline&height=223&name=%E5%9B%BE%E7%89%87.png&originHeight=823&originWidth=1138&size=231877&status=done&width=308)\n**Mapping工具**\n\n- 该功能尚未开发完成，目标是能够根据DefectCode对多张Glass，或者多个Lot或者一段时间内的defect进行Mapping，请后续担当继续开发，如有问题可以联系我。\n#### 1.3.2 IM Monitor\nIM Monitor主要功能与实现如下：\n\n- 通过LotID查询所有测试过得工序，并显示IM图片\n- IM图片查看时具有放大镜功能\n- 点击图片时自动计算点位与在LC机台上的位置\n- 点击发送Abnormal单跳转到Abnormal单界面，在Abnormal单可以输入不良点位，并对图片进行标注\n- 提交Abnormal单时自动计算，防止出现错误提交重复提交的情况\n- 提交后的Abnormal单自动保存到FTP并且同步到共享中，工程师打开软件可以看到之前开的Abnormal记录\n- 工程师可以对Abnormal单进行回复，回复后再记录界面显示回复情况，回复人等信息\n- 附加Mura管理手册，便于Monitor人员判断不良原因\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567589798924-4c6d99bc-c741-411a-bbef-00940806f74e.png#align=left&display=inline&height=923&name=%E5%9B%BE%E7%89%87.png&originHeight=923&originWidth=1239&size=116133&status=done&width=1239)\n#### 1.3.3  THK Monitor\n注：THK Monitor目的是统一管理膜厚数据，简化膜厚数据处理。\nTHK Monitor实现功能主要如下：\n\n- 从共享中中获取各设备测试历史，计算测试结果。 →**后续担当应该严格要求到班组将数据放入相应文件夹中**\n\n- 拖拽计算测试结果（支持用户把文件直接拖拽到软件中，自动计算）\n- 支持同时查看两次测试结果（3D/Cross可以放到一个界面）\n\n因为测试数据复杂，计算逻辑和可视化逻辑需要的步骤较多，目前THK Monitor不足之处：\n\n- 文件命名必须严格遵循命名规则 （详见5.1）\n\n- 对于3D的显示没有合适的Chart控件，所以没有显示三维图形。 →需要后续开发\n- \n\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567648084311-11142500-65b7-4d1a-b92c-ae0f6e3de52d.png#align=left&display=inline&height=785&name=%E5%9B%BE%E7%89%87.png&originHeight=785&originWidth=1162&size=102181&status=done&width=1162)\n\n#### 1.3.4 设备管理系统\n设备管理系统承担着我们科室自动点检，设备状态监控，产能监控的重要使命。该部分需要详细介绍并后续担当重点优化与开发。\n##### 1.3.4.1 设备管理系统的两个软件版本\n为了优化设备的管理，在之前设备管理系统的基础上，开发了两个版本，他们在Array智造主界面的以下位置。\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567648651670-a55ae6b8-0281-4584-9d12-209cb0201242.png#align=left&display=inline&height=222&name=%E5%9B%BE%E7%89%87.png&originHeight=222&originWidth=1110&size=20182&status=done&width=1110)\n\n\n- 设备监控为旧版软件，包括了设备监控的绝大多数功能。\n- 设备管理为新版软件，包括了HoldList与自动点检、ProcssData查看等新功能\n\n**计划将旧版软件所有功能迁移到新版软件，但是时间有限，请后续担当继续推进。**\n##### 1.3.4.2 自动点检功能\n自动点检实现是将ProcessData中最新三张Glass数据与Spce表对比，如果其中有连续两张Glass都OutOfSPC，则提示设备参数异常。\n所以后续担当主要维护以下几点\n\n- 根据实际生产情况调整Spec\n- 根据实际生产情况设置报警逻辑\n- 根据工程师经验为每个参数设定调整建议和影响    \n\n同时自动点检功能为一些重点参数设定了快捷查看入口，对于TactTime也设立了可视化图表\n\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567649535066-521bef35-9c16-4555-8513-944b96f6c7fe.png#align=left&display=inline&height=825&name=%E5%9B%BE%E7%89%87.png&originHeight=825&originWidth=1354&size=175515&status=done&width=1354)\n\n##### 1.3.4.3 Tank监控\n为了避免Tank切换导致的批次性工艺不良，在主界面也可以显示目前PLN设备使用的Tank情况\n计算逻辑是：根据设备最近一张Glass使用Tank情况判断目前设备使用哪个Tank\n##### 1.3.4.4 VCD时间点检\n计算逻辑：根据设备最近几张Glass VCD工艺时间计算两个VCD Chamber的工艺时间差\n\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567649710578-67fa62aa-c044-4c18-8f1d-8f4920ac0a21.png#align=left&display=inline&height=493&name=%E5%9B%BE%E7%89%87.png&originHeight=493&originWidth=347&size=27243&status=done&width=347)\n\n\n##### 1.3.4.5 CD波动调查\n计算逻辑：根据设备ProcessData将某个Lot CD波动相关数据直观展示\n##### 1.3.4.6 Hold List\nHoldList实现逻辑相对较为复杂，具体实现方式\nBO自动发送邮件 → 通过OutLook功能自动下载附件至D盘→利用FileGee同步文件到共享→设备监控软件读取HoldList文件并筛选与Track相关Lot\n该功能重点在于邮箱附件的自动保存，但是这种方式费时费力还不好维护（OutLook的自动化功能也不稳定，后续我去CIM以后再进行修改吧）\n##### 1.3.4.7 自动化点检表\n为应对体系审核，需要对点检表进行自动生成，该功能放在设备管理系统中，具体交由王志敏维护，详见1.3.5\n##### 1.3.4.8 ProcessHistroy\n为便于查看ProcessData History，模仿产线内History功能。\n该功能未开发完成，有以下遗留问题：\n\n- 数据获取耗时较长，计算逻辑有待优化\n- 未加入可视化图表和数据筛选功能，需要进一步开发\n- \n\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567650482748-27b87d01-0913-4f86-936f-92192ab25a6d.png#align=left&display=inline&height=981&name=%E5%9B%BE%E7%89%87.png&originHeight=981&originWidth=1303&size=65177&status=done&width=1303)\n\n#### 1.3.5 自动化点检表\n为应对体系检查，需要生成点检表。针对该问题开发功能如下：\n\n- 输入点检人，点击点检按钮对当日所有设备进行点检\n- 对于NG项目备注中提示NG原因，并提示已经调整OK\n- 点击保存点检结果后将点检数据保存到共享中\n- 点击SPEC设置，可以查看设定的Spec值，（暂未加入修改Spec功能，修改需要在共享中修改Txt文件）\n- 隐藏功能：选择StartTime→点击管理员功能  就可以实现从选择日期开始所有日期点检表的检查和保存\n\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567671153504-9972651b-53d9-427a-9855-720d91be2e91.png#align=left&display=inline&height=971&name=%E5%9B%BE%E7%89%87.png&originHeight=971&originWidth=1292&size=81412&status=done&width=1292)\n\n#### 1.3.6 不良监控系统\n为了优化不良调查流程，减少重复工作，开发了不良监控系统。\n目前实现功能如下：\n\n- 根据设备，日期，自动分析进行过的Lot，生成相关的Layer。\n- 根据用户选择的Layer，输入的Defect Code，生成Trend（时间按照Track进行Mask时间），Chamber别，Mapping结果。 （如果DefectCode输入所有不良，则刷取所有Code）\n- 支持切换DIPI和FIPI结果\n\n该功能仍有许多优化空间：\n\n- 目前尚未加入型号别刷取\n- 刷取速度很大一部分取决于电脑速度，可以通过更加优化的异步等方法优化。\n- 每次刷取是对时间和DFS资源的巨大负担，后续可以通过自动记录数据库的方式优化。（数据库已经进行过开发，但是受限于CS架构模式，暂时弃用）\n\n我们最终的目的是，10W左右的数据量能够在10s内显示出来，这必须依托于CS架构，所以我先去CIM学习了，后续开发可以联系我。\n\n#### 1.3.7 产能监控\n产能监控主要功能如下：\n\n- 根据用户选择设备，日期读取ProcessData，自动计算TactTime\n- 根据过滤条件选择计算相应TactTime\n- 计算cycleTime（但是cycleTime中部分EXP单元时间不正确，后续可以酌情调整）\n\n\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567673699483-867c9f77-37a9-4c97-9d64-92738be78158.png#align=left&display=inline&height=771&name=%E5%9B%BE%E7%89%87.png&originHeight=771&originWidth=1240&size=101617&status=done&width=1240)\n\n#### 1.3.8 其他辅助功能\n智能制造中也开发了多项辅助功能，类似人工判图，Recipe自动生成等，请知悉。\n#### 1.3.9 Recipe自动备份 参考附件【14】\nRecipe自动备份是确保重要数据不丢失的手段。其实现方法是通过FileGee进行的，附件中提供了FileGee使用手册。\n目前建立自动备份的方法已经交接给张雪，姜欢欢。请知悉\n\n### 1.4 智能制造的开发 参考附件【15】\n#### 1.4.1 Array智造软件的发布与安装\n Array智造是一种CS构架的软件。CS架构是一种较为早期的软件架构模式，大多数的数据处理逻辑与运算是在客户端进行的，这种模式在效率和用户体验上有一定提升，但是每次用户安装和升级需要大量的工作。这里着重介绍一下Array智造软件的发布与安装。\n\n- 发布采用Visual Stuido自带的OneClick模式（类似于OIC的发布），这样的好处在于安装包存放在服务器或者共享中，提供给用户可以是一个2k的小安装程序。\n- 发布时开发者设置好 版本号，运行环境，安装地址后点击发布即可（具体有疑问联系我）\n- Array智造采用了 Task.Run（多线程）等.net FrameWork4.5 以上才有的功能，所以Win7电脑安装Array智造时需要先安装 .net FrameWork 4.5即以上  参考附件【16】\n\n#### 1.4.2 Array智造 开发环境构建\n\n- Array智造开发工具为 VS（Visual Studio 2017即以上），该软件有微软提供的社区免费版本，百度一下即可\n- Array智造选用的主要开发语言为C#，少量功能采用了 前端语言实现（html js css），后续担当简单学习即可，以解决实际工作需求为目的。\n- 经过大量对比测试，Array选用的技术框架为 Winform，这是一种比较古老的技术框架，但是适配性好，上手容易。\n- UI控件集选用了MetroFramework UI，并且根据其源码进行了一定程度的定制开发。推荐后续担当采用此框架\n\n#### 1.4.3 Array智造源代码\n\n- 因为Array智造本质也属于一种比较宝贵的脑力活动资产，源代码保留在我之前使用的科室笔记本电脑中，已经交际给担当 姜欢欢。\n#### 1.4.4 智能制造开发所需的一些学习资源  参考附件【17】\n\n- 编程学习推荐在网易云课堂搜索C#进行学习\n- 附件中提供了少量学习资料，多数学习教程存放在 科室笔记本电脑  D盘 学习资料中\n- 在Bilibili上也有很多C#语言相关的学习资源\n\n",
      "data": {
        "title": " 【智能制造之路】智能制造简述",
        "date": "2020-01-22 15:56:31",
        "tags": [
          "智能制造",
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/zhi-neng-zhi-zao-jian-shu.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "zhi-neng-zhi-zao-jian-shu"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "vue",
      "slug": "vue",
      "used": true
    },
    {
      "index": -1,
      "name": "值得一读",
      "slug": "worth",
      "used": true
    },
    {
      "index": -1,
      "name": "前端拾遗",
      "slug": "FE",
      "used": true
    },
    {
      "index": -1,
      "name": "SQL",
      "slug": "SQL",
      "used": true
    },
    {
      "index": 3,
      "name": "代码仓库",
      "slug": "code",
      "used": true
    },
    {
      "index": -1,
      "name": "智能制造",
      "slug": "smartManufacture",
      "used": true
    },
    {
      "index": -1,
      "name": "python",
      "slug": "python",
      "used": true
    },
    {
      "index": -1,
      "name": "大数据",
      "slug": "bigData",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "分类",
      "openType": "Internal"
    },
    {
      "link": "/tag/FE/",
      "name": "前端",
      "openType": "Internal"
    },
    {
      "index": 3,
      "link": "/tag/python/",
      "name": "Python",
      "openType": "Internal"
    },
    {
      "link": "/tag/bigData/",
      "name": "工业与大数据",
      "openType": "Internal"
    },
    {
      "index": 5,
      "link": "/tag/code",
      "name": "代码库",
      "openType": "Internal"
    }
  ]
}